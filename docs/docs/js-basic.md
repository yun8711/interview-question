---
outline: deep
---



# js 基础



## 核心知识

### 原型、原型链

1、**prototype **和 `__proto__`

每个函数都有一个 `prototype` 属性，它是函数在创建时由 js 引擎添加到函数上的，它的指向是一个对象，被称为**原型对象**或**原型**。

原型对象上包含了可以由该构造函数的所有实例共享的属性和方法。

对象包含一个 `[[Prototype]]` 属性（浏览器中通过`__proto__`可以访问，通过`Object.getPrototypeOf() `方法可以获取），它的指向是创建这个对象的构造函数的 `prototype`。

所以说，`obj.__proto__ === test.prototype`

2、**原型链**

因为对象的`__proto__`属性指向了“原型”对象，而这个“原型”对象又指向它自己的“原型”对象，这样递归下去，就形成了一个原型链。

原型链是 js 中一种实现继承的机制。当你访问一个对象的属性时，如果对象自身没有这个属性，那么就会沿着原型链查找这个属性，直到找到为止或者到达原型链的末尾。

所以说，原型对象上的属性和方法可以由该函数的所有实例共享。

原型链的终点是null。

3、**函数与对象的关系**

函数是一种特殊的对象，它有一个特殊的功能，就是可以被调用（执行）。当一个函数被用作构造函数来创建对象时，这个函数就被称为构造函数。

在 js 中，所有的对象都是由函数创建的：

- 实例对象通过 new 关键字显式调用构造函数来创建
- 字面量对象虽然没有显示的调用构造函数，实际上也是 js 解释器通过` let xx=new Object()` 来创建的

4、**构造函数与普通函数**

在写法上：

- 构造函数通常以大写字母开头，以区别于普通函数
- 构建函数使用 new 关键字来创建新的对象实例

使用目的上：

- 构造函数主要用于创建和初始化一个对象
- 普通函数通常用于执行特定的任务或计算并返回结果

<br/>

### `new`操作符的实现过程

1. 在当前函数作用域内在中创建一个新的空对象，即`{}`
2. 为这个对象添加`__proto__`属性，让它指向构造函数的原型对象，并为原型对象指定constructor属性，指向构造函数
3. 调用`apply`或`call`方法，切换上下文，执行构造函数方法，为对象添加其他属性
4. 返回这个对象，

```js
//Fun为构造函数, args表示传参
function myNew(Fun, ...args) {
    // 1.在内存中创建一个新对象
    let obj = {};
    
    // 2.把新对象的原型指针指向构造函数的原型属性
    obj.__proto__ = Fun.prototype;
    
    // 3.改变this指向，并且执行构造函数内部的代码（传参）
    let res = Fun.apply(obj, args);
    
    // 4.判断函数执行结果的类型
    if (res instanceof Object) {
        return res;
    } else {
        return obj;
    }
}

function One(name, age) {
    this.name = name;
    this.age = age;
}
let a = new One();
console.log(a);


let obj = myNew(One, "XiaoMing", "18");
console.log("newObj:", obj);
```



### this

this 并不是一个好的设计，它会随着作用域不同而变化。

this代表函数调用相关联的对象，通常叫做函数上下文

1、函数调用模式

在全局作用域或函数外部使用this，它指向全局对象。非严格模式下指向全局对象（在浏览器中，全局对象是window，在 nodejs 中，全局对象是 global），严格模式下是undefined

```js
console.log(this); // window
```

2、方法调用时

在函数内部使用this，它的值取决于函数如何被调用。如果函数是作为一个方法被调用的，那么this就指向调用该方法的对象

```js
let obj = {
  name: 'John',
  sayHello: function() {
    console.log('Hello, ' + this.name);
  }
};

obj.sayHello(); // Hello, John
```

在这个例子中，sayHello方法内的this指向obj对象。

3、构造器调用模式

在构造函数中使用this，它指向新创建的对象实例。

```js
function Person(name) {
  this.name = name;
}

let john = new Person('John');
console.log(john.name); // John
```

在这个例子中，Person构造函数中的this指向新创建的对象john。

4、apply/call/bind 调用模式

当函数使用call、apply或bind方法被调用时，this指向传递给这些方法的第一个参数

```js
function sayHello() {
  console.log('Hello, ' + this.name);
}

let john = { name: 'John' };
let jane = { name: 'Jane' };

sayHello.call(john); // Hello, John
sayHello.call(jane); // Hello, Jane
```

在这个例子中，sayHello函数中的this分别指向john和jane对象。

5、箭头函数中

箭头函数中使用this，指向定义函数时的父级作用域的 this，且无法被改变

```js
let obj = {
  name: 'John',
  sayHello: function() {
    setTimeout(() => {
      console.log('Hello, ' + this.name);
    }, 1000);
  }
};

obj.sayHello(); // Hello, John
```

优先级：

构造器调用 > apply/call/bind > 方法调用 > 函数调用



### 作用域、作用域链

作用域是可访问变量的集合，它定义了变量、对象、函数的可访问性。根据可访问性，作用域可分为：

- 全局作用域：代码中任何地方都能访问到的变量、函数、对象等，如：最外层变量和函数，未使用var声明的变量，window对象上的属性和函数
- 函数作用域：函数调用时创建的一个作用域，声明在函数内部的变量、函数、对象等只在函数体内可以访问到，包括函数的形参
- 块级作用域：ES6 引入的新概念，let 和 const 声明的变量具有块级作用域。块级作用域是指在 `{} `中声明的变量只能在这对花括号中被访问，不能在花括号外部被访问。

变量的作用域指的是该变量的可访问区域，一个变量只能在其所处的作用域内被访问，在作用域外是不可见的。

作用域是一个存放变量的独立空间，它们之间可以相互嵌套，形成引用关系，这条链叫做作用域链。

作用域链 是 JavaScript 解析和查找变量的机制。当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。

作用域链的前端，是当前执行的代码所在环境的变量对象。作用域链的下一个变量对象来自外部环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。  

标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误）。 



### 闭包

**核心**

让变量驻留在内存，不被回收。正常的函数在执行完后，内部的局部变量就被释放了，而当函数内部的局部变量一直被引用时，不会被回收。

**形成闭包的关键点**

1、函数嵌套函数：外层函数与内层函数形成嵌套，同时把内部函数 return 出去

2、内部函数引用外部函数的变量

3、返回内部函数：外部函数返回内部函数，使得内部函数可以在外部函数之外被执行。

```js
function outerFunction(outerVariable) {
  return function innerFunction(innerVariable) {
    console.log('outerVariable:', outerVariable);
    console.log('innerVariable:', innerVariable);
  }
}

const newFunction = outerFunction('outside');
newFunction('inside'); // Logs: outerVariable: outside, innerVariable: inside
```

**应用场景**

1、数据封装和私有变量：闭包可以用来模拟私有变量，因为闭包内的变量只能通过闭包函数来访问。  

```js
function createCounter() {
  let count = 0;
  return {
    increment: function() {
      count++;
    },
    getCount: function() {
      return count;
    }
  };
}

const counter = createCounter();
counter.increment();
console.log(counter.getCount()); // 输出：1
```

2、函数工厂：可以使用闭包创建可以记住状态的函数。  

```js
function createAdder(x) {
  return function(y) {
    return x + y;
  };
}

const add5 = createAdder(5);
console.log(add5(2)); // 输出：7
```

比如：使用闭包设计单例模式

3、模块模式：使用闭包可以创建公有和私有方法和变量。

```js
const myModule = (function() {
  let privateVar = 0;
  const publicAPI = {
    increment: function() {
      privateVar++;
    },
    getPrivateVar: function() {
      return privateVar;
    }
  };
  return publicAPI;
})();

myModule.increment();
console.log(myModule.getPrivateVar()); // 输出：1
```

4、在异步编程中维持状态：闭包可以在异步操作中保持变量的状态。

```js
for (var i = 0; i < 5; i++) {
  (function(i) {
    setTimeout(function() {
      console.log(i); // 输出：0, 1, 2, 3, 4
    }, i * 1000);
  })(i);
}
```



**注意点**

虽然闭包很有用，但是过度使用闭包可能会导致内存泄漏，因为闭包会阻止垃圾回收器清理那些不再被使用的变量



### js中实现继承的方式

- 单独使用原型链：
  - 思路：把实例的原型指向另一个对象，在实例和原型之间形成一条链。
  - 问题：（1）不同实例间的引用类型属性会共享；（2）子类型在实例化时不能给父类型的构造函数传参
- 借用构造函数：
  - 思路：通过`call`或`apply`方法，在子类构造函数中调用父类构造函数，解决不能给父类型传参的问题；
  - 问题：构造函数中的方法定义不能重用，也不能访问父类原型上定义的方法。
- 组合继承（常用）：
  - 思路：使用原型链继承原型上的属性和方法，通过盗用构造函数继承实例属性
  - 问题：效率不高，父类构造函数始终会被调用2次，一次在创建子类原型时调用，一次在子类构造函数中调用
- 原型式继承：`Object.create()`
  - 思路：创建一个临时构造函数，将传入的对象副本（浅复制）赋值给这个构造函数的原型，然后用这个临时类型创建实例。
  - 问题：属性中包含的引用值始终会在相关对象间共享
- 寄生式继承：
  - 思路：创建一个实现继承的函数，以某种方式增强这个函数的实例对象，然后返回这个对象
  - 问题：给对象添加函数会导致函数难以重用，与构造函数模式类似
- 寄生式组合继承：（最佳）
  - 思路：以寄生式的方式取得父类原型的副本，然后将子类的构造函数设置为这个副本



### js 中对象创建的方式

**字面量的形式直接创建对象**，创建大量相似对象时，会产生大量的重复代码

1. 工厂模式：用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。缺点：它只是简单的封装了复用代码，无法和某个类型联系起来，没有建立对象和类型间的关系。
2. 构造函数模式：即通过 `new Function()`的方式创建，新建的对象与原型通过 prototype 建立了联系。缺点：造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，每次都会新建一个函数对象，浪费内存，国灰函数是所有的实例都可以通用的。
3. 原型模式：每个函数都有一个 prototype 属性，用来指向原型对象，因此可以使用原型对象来添加公共属性和方法，实现代码复用。缺点：不能通过传入参数来初始化值；如果存在引用类型的值，那么所有实例将共享一个对象。
4. 组合构造函数模式+原型模式：创建自定义类型最常见的方式，通过构造函数初始化对象的属性，通过原型对象实现函数方法的复用。缺点：由于使用了两种不同的模式，代码的封装性不够好。
5. 动态原型模式：将原型方法赋值的创建过程移动到构造函数内部，通过判断属性是否存在，可以实现仅在第一次调用函数时对原型对象赋值一次的效果，这种方式很好的对上面的混合模式进行了封装
6. 寄生构造函数模式：与工厂模式基本相同，主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展，这样既不用修改原来的构造函数，也扩展了对象。



### 异步编程的实现

js 中的异步机制有以下几种：

1、**回调函数**

缺点是多个回调函数嵌套时会造成回调地狱，回调函数间耦合度高，不利于维护

2、**Promise 方式**

将嵌套的回调函数使用 then 方法作为链式调用，但是可能造成代码语义不明确

3、**generator 方式**

通过转移函数的执行权实现，当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再转移回来。此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如 说 co 模块等方式来实现 generator 的自动执行。

4、**async 函数方式**

async 是 generator 和 promise 实现的一个自动执行的语法糖，内部自带执行器，当函数内部执行到 await 语句时，如果语句返回一个 promise 对象，则函数会等待它的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑转化为同步的顺序来书写，并且这个函数可以自动执行。





### apply、call、bind

作用相同，都可以改变函数的 this 上下文

- apply：接受2 个参数，一个是函数运行的作用域（也就是 this 指向的值），另一个是一个参数数组/类数组
- call： 与 apply 相似，但是它接受的是一个参数列表，而不是一个参数数组，也就是说接收参数数量不固定
- bind：与 apply 和 call 不同，bind 是创建一个新的函数，而不会立即执行，它的参数就是 this 指向



### 深拷贝与浅拷贝

深拷贝和浅拷贝是两种常见的复制对象的方法，它们之间的主要区别在于如何处理对象的属性值

浅拷贝（Shallow Copy）：创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。

深拷贝（Deep Copy）：创建一个新对象，复制原始对象的属性值，如果属性值是引用类型，会递归复制其内部的属性，直到所有引用类型的属性都被复制为基本类型的属性。所以，修改一个对象的属性不会影响到被复制的对象。



深拷贝实现方式：

1、`JSON.parse(JSON.stringify(obj))`

序列化和反序列化，最简单的深拷贝方法，但它有一些限制：

- 取不到值为 undefined 的 key
- 不能复制函数和循环引用的对象
- Date 对象会被转变为 date 字符串
- 不能拷贝对象原型链上的属性和方法

2、递归

可以复制任何类型的对象，但需要注意防止循环引用导致的无限递归

参见[手写深拷贝](./hand-written)

3、第三方库

如：lodash 的 _.cloneDeep 方法

4、扩展运算符或Object.assign

只能对第一层属性进行拷贝，如果属性值是对象，那么这个属性的拷贝仍然是浅拷贝



### ESModule和CommonJs异同

- CommonJS的require是同步的，只适合用在服务端；ESM也可以用在服务端，但还需要遵循一些特殊的规则；
- ESM支持加载CommonJS模块，但CommonJS不能加载ESM模块
- CommonJS是对模块的浅拷贝（就是模块内部的变化，会反映到模块外），并且可以对它重新赋值；ESM是对模块的引用，且是只读的，不能改变其值，类似const，还存在提升
- CommonJS是运行时加载，ESM是编译时输出接口，可以对模块进行静态分析
- CommonJS遇到循环依赖时，只输出已经执行的部分，后续的输出或变化不影响已输出的变量；而ESM加载时变量不会被缓存，真正取值的时候就能取到最终值
- CommonJS的this指向当前模块；ESM的this指向undefined



## ES6+

### let、const、var的区别

- let、const具有块级作用域，var没有
- var声明的变量可以重复声明，const、let不允许
- 暂时性死区：由于const、let不存在变量提升，所以在声明前使用变量会报错，形成暂时性死区。var可以提升变量，所以没有。
- 初始值设置：var、let可以没有初值，const必须设置初始值
- 指针指向：let创建的变量可以更改指针指向，即重新赋值。const不允许，它保证指针的指向的内存地址不变，对于基本类型值就在内存地址，对引用类型变量指向内存地址，只要地址不变，就代表值没变



### Proxy

是 JavaScript 的内置对象，用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。

创建一个 Proxy 对象需要两个参数：目标对象（target）和处理程序对象（handler）。处理程序对象是一个包含一组方法的对象，这些方法用于拦截目标对象的操作。 

```js
let target = {};
let handler = {
  get: function(target, prop, receiver) {
    console.log(`Getting ${prop}`);
    return Reflect.get(target, prop, receiver);
  },
  set: function(target, prop, value, receiver) {
    console.log(`Setting ${prop} to ${value}`);
    return Reflect.set(target, prop, value, receiver);
  }
};

let proxy = new Proxy(target, handler);

proxy.name = 'GitHub Copilot';  // 输出 "Setting name to GitHub Copilot"
console.log(proxy.name);  // 输出 "Getting name" 和 "GitHub Copilot"
```

Proxy 提供了很多其他的拦截操作，包括 apply（拦截函数调用）、has（拦截 in 操作符）、deleteProperty（拦截 delete 操作符）、ownKeys（拦截 Object.getOwnPropertyNames 方法）等。



### 箭头函数

箭头函数是 ES6 中引入的一种新的函数语法。语法更简洁，没有自己的this、arguments、super、new.target。更适用于本为需要匿名函数的地方，并且它不能做构造函数。

箭头函数的特性：

- 书写简洁：一个参数时可省略小括号，函数体只有一个返回语句时可省略大括号
- 没有自己的this：它只从自己作用域的上一层继承this，所以在定义时已经确定了this指向，不会改变
- 不能作为构造函数：没有prototype
- 没有arguments 对象：可以使用rest参数来访问参数列表
- 不能用作Generator函数，不能使用yeild关键字



### arguments

一个类数组对象，代表了传递给一个函数的参数列表，在函数内部，可以使用 arguments 对象来访问所有传递给该函数的参数，包括那些没有对应形参的实参。

它不能显示的创建，只有函数中可用。

作用：可以不用给函数设定形参，而动态的通过arguments为函数加入参数。



### class 类

ES6 引入了 class 关键字来实现面向对象编程的类。类是一种特殊的函数，可以用来创建对象。类的语法提供了一种更清晰、更简单的方式来创建对象和处理继承。

类（class）的本质就是函数，可以通过 typeof 操作符验证



### 尾调用优化

尾调用优化（Tail Call Optimization，TCO）是一种在某些编程语言中用于提高递归函数性能的技术。在 js 中，尾调用优化是 ES6 标准的一部分。

尾调用是指**函数的最后一步是调用另一个函数**

```js
function foo() {
  return bar();  // 这是一个尾调用
}
```

函数调用会在内存形成一个"调用记录"，又称"调用帧"（call frame），保存调用位置和内部变量等信息。

如果在函数A的内部调用函数B，那么在A的调用记录上方，还会形成一个B的调用记录。等到B运行结束，将结果返回到A，B的调用记录才会消失。如果函数B内部还调用函数C，那就还有一个C的调用记录栈，以此类推。所有的调用记录，就形成一个["调用栈"](https://zh.wikipedia.org/wiki/调用栈)（call stack）。

尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。

使用尾调用的话，因为已经是函数的最后一步，所以这时可以不再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。

**注意**：虽然 ES6 标准规定了尾调用优化，但并非所有的 JavaScript 引擎都实现了这个特性





### Promise

异步编程的一种解决方案，解决了回调地狱的问题

它是一个对象，也可以理解为一个容器，它可以获取异步操作的消息。

Promise 的实例有 3 个状态：Pending 进行中，Resolved 已完成，Rejected 已拒绝，它的状态只能从 pending->fulfilled:Resolved或 pending->rejected:Rejected。

优点：

有了 Promise 对象（对象可以保存状态，函数不可以，除了闭包），可以将异步操作以同步的流程表达出来，避免了回调地狱。提供了统一的接口，使得控制异步操作更加容易。

缺点：

无法取消 Promise，一旦创建就会立即执行；如果不设置回调函数，Promise 内部的错误不会反应到外部；当处理pending 状态时，无法得知具体进展到哪一步（刚开始还是即将完成）

**原型方法**

then()、catch()、finally()

**常用方法**

Promise.all：同时执行多个 promise 实例，包装成一个新的 Promise 实例。有任何一个失败则该 Promise 失败，返回第一个失败的子 Promise 的结果。

Promise.race：任意一个promise被拒绝或者成功，则会采用第一个promise作为他的返回值。

Promise.any：任意一个完成时就会终止，会忽略所有被拒绝掉的promise，直到第一个promise完成

Promise.allSettled：所有promise被拒绝后会返回一个拒绝的promise数组



### async/await

async/await也是异步编程的解决方案，是基于generator函数对promise封装的语法糖，它内置执行器，不需要额外的调用直接会自动执行并输出结果。

async 函数返回的是一个 Promise对象，如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve()封装成 Promise 对象。

对比 Promise 的优势：

- 避免 then的链式调用带来的可读性问题
- Promise 传递中间值不方便，而 async/await 是同步写法，传递中间值非常优雅
- 错误处理友好，可以使用 try/catch
- 调试友好

适用场景：

处理多个 Promise 组成的then 链。比如多个步骤，每个步骤都是异步，且依赖于上一个步骤的结果。



## js 内存管理

### 堆和栈

堆和栈的概念存在于数据结构和操作系统中，js中常说的是针对操作系统。

在数据结构中：

- 栈中数据先进后出（像个有底的桶）
- 堆是一个优先队列，按优先级来排序，可以按大小来规定

在操作系统中，内存分为栈区和堆区：

- 栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈
- 堆区内存一般由开发者分配释放，若不释放，则由垃圾回收机制回收



### js 内存管理

**生命周期/主要步骤**

1、分配内存：由 js 引擎自动分配

2、使用内存：当使用变量时，实际正在使用分配给该变量的内存

3、释放内存：当数据不再需要进，js 引擎会自动释放其内存，这个过程称为垃圾回收

**内存限制**

64 位系统约 1.4GB，32 位约为 0.7GB

**内存分配**

栈：存放基本数据类型（静态数据）直接在栈空间内分配，引擎知道数据的大小，所以会分配固定数量的内存；包括：string、number、boolean、undefined、null、指向对象和函数的引用

堆：引用数据类型（动态数据）在堆内存中开辟空间，并将该空间的指针存储在栈中，变量指向的是堆内存的地址。

池：一般也归类栈中，一般存放常量，也叫常量池。

特殊的：闭包中的变量是在堆内存中的。

字符串常量池：字符串存在字符串常量池中，被栈或堆上的变量引用。如果变量的值是字符串字面量，则在栈上的变量直接引用字符串常量池中的字符串；如果是字符串是 new String 创建的，则会在堆上创建 String 对象，指向字符串常量池中的字符串，栈上变量指向堆中的 String 对象。



### js垃圾回收/GC

主要依赖于可达性的概念，简单来说，如果一个值无法通过根（全局对象）直接或间接访问，那么这个值就被认为是不可达的，因此可以被回收。

- 引用计数（Reference Counting）：早期使用的垃圾回收算法，现在已经很少使用。基本思想是跟踪每个值的引用数。当声明一个变量并将一个引用类型值赋给该变量时，这个值的引用数就会加1。当引用被删除时，引用数就会减1。当引用数变为0时，说明该值不再需要，因此可以被回收。但是，引用计数算法有一个问题，那就是无法处理循环引用。
- 标记-清除（Mark-and-Sweep）：这是最常用的垃圾回收算法。它分为两个阶段：标记阶段和清除阶段。在标记阶段，垃圾回收器会遍历所有的对象，标记活动对象（即仍在使用的对象）和非活动对象（即可以被删除的对象）。在清除阶段，垃圾回收器会删除所有被标记为非活动的对象，并回收它们的内存。



### v8 的 GC

主要通过两种算法：标记-清除（Mark-Sweep）和分代收集（Generational Collection）

- 标记-清除（Mark-Sweep）：这是 V8 引擎的主要垃圾回收算法。在标记阶段，垃圾回收器会遍历所有的对象，标记活动对象（即仍在使用的对象）和非活动对象（即可以被删除的对象）。在清除阶段，垃圾回收器会删除所有被标记为非活动的对象，并回收它们的内存。这个过程会导致内存碎片化，因此 V8 还会进行内存整理，将活动对象移动到一起。  
- 分代收集（Generational Collection）：V8 引擎将内存分为新生代（Young Generation）和老生代（Old Generation）两部分。新生代中的对象是生命周期短的对象，老生代中的对象是生命周期长的对象。新生代使用 Scavenge 算法进行垃圾回收，老生代使用 Mark-Sweep 和 Mark-Compact 算法进行垃圾回收
  - Scavenge 算法：Scavenge 算法将新生代内存空间分为两部分，一部分只用来分配新对象，另一部分空闲。当进行垃圾回收时，会检查这部分内存中的活动对象，然后将这些活动对象复制到另一部分空闲内存中，并清除原来内存中的所有对象。然后交换这两部分内存的角色，重复这个过程
  - Mark-Compact 算法：Mark-Compact 是一种用于老生代的垃圾回收算法。它首先标记所有活动对象，然后将所有活动对象向一端移动，然后直接清除端边界以外的内存。



### 内存泄漏

由于不正确的内存管理，导致程序无法释放已经不再使用的内存。这可能会导致应用程序的内存使用量逐渐增加，从而影响应用程序的性能，甚至导致应用程序崩溃。

1、不必要的全局变量：因为全局变量在整个应用程序的生命周期内都不会被回收

2、未清除的定时器：如果定时器的回调函数引用了外部变量，那么这些变量在定时器存在期间都不会被回收

3、不正确的闭包：如果闭包引用了外部函数的变量，那么这些变量在闭包存在期间都不会被回收

4、脱离 DOM 的引用：如果保留了对已删除 DOM 元素的引用，那么这些 DOM 元素的内存就不会被回收



## 其他

#### for...in 和 for...of

for...of：

- es6 新增，允许遍历实现了 Iterator 接口的数据结构，如 Map、Set、数组、对象、类数组对象、字符串、Generator 对象
- 遍历时获取的是对象的键值
- 只遍历当前对象
- 对数组遍历只返回数组的下标对应的属性值

for...in：

- es3 中的方法，获取对象的键名
- 会遍历对象的整个原型链，性能差
- 对数组遍历会返回所有可枚举属性，包含原型链上的



### Object.assign和扩展运算符

两者都是浅拷贝，

- Object.assign会把源对象的可枚举属性复制到目标对象中，如果重名会覆盖；
- 扩展运算符把数组或对象中的每个值拷贝到一个新的数组或对象，不复制继承的属性，但会复制Symbol属性



### fetch

es6 中出现的原生 js 语法，ajax 的替代品，基于 Promise 对象封装，代码结构简单。

优点：

- 语法简洁，更加语义化
- 基于 Promise 实现，支持 async/await
- 更加底层，提供了丰富的 api，如 request、response

缺点：

- 只对网络请求报错，对 400、500都当作成功的请求
- 默认不带 cookie，需要添加配置项：`fetch(url,{credentials:'include'})`
- 不支持 abort，不支持超时控制
- 不能原生监测请求的进度，xhr 可以
