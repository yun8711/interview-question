[TOC]



### 一、数据类型

#### 1 数据类型有哪些，区别是什么

原始数据类型：Undefined、Null、Boolean、Number、String、Object，ES6新增Symbol，ES2020新增BigInt

引用数据类型：object，它的子类有function、array，其他的有：map、weakMap、set、weakSet、Date、RegExp、Math等

区别主要在于存储位置不同：

- 原始数据类型存储在栈（stack）内存中，占用空间小、大小固定、属于频繁使用的数据
- 复杂数据类型存储在堆（heap）内存中，占据空间大，大小不固定。在栈中存储了指针，该指针指向堆中该实体的地址。



#### 2 堆和栈的概念

堆和栈的概念存在于数据结构和操作系统中，js中常说的是针对操作系统。

在数据结构中：

- 栈中数据先进后出（像个有底的桶）
- 堆是一个优先队列，按优先级来排序，可以按大小来规定

在操作系统中，内存分为栈区和堆区：

- 栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈
- 堆区内存一般由开发者分配释放，若不释放，则由垃圾回收机制回收



#### 3 包装类型

js 中的基本类型没有属性和方法，只有对象才有属性和方法，但是为了便于操作基本类型的值，在调用基本类型的属性或方法时，会隐式的将基本类型值转换为包装对象，以便调用原型上的方法

也可以使用 Object 函数显式的将基本类型转换为包装类型。

也可以使用 valueOf 方法将包装类型转成基本类型。



#### 4 数据类型检测

**typeof**

typeof：判断string、number、boolean、undefined、function为预期，array、object、null等被判断为object

**instanceof**

`实例 instanceof 构造函数`：判断对象类型，原理是判断**构造函数的原型**是否在**实例的原型链上**

**constructor**

`constructor`：通过访问原型上的constructor属性（它指向对象的构造函数）来判断数据类型，如果原型被重写，则不能判断

**`Object.prototype.toString.call()`**

通过Object的原型上的toString方法，而像array、function等类型都重写了toString方法

```js
const a=Object.prototype.toString;
a.call(function(){})
// '[object Function]'
```





`Array.prototype.isPrototypeOf(obj)`：判断原型对象

`obj.__proto__===Array.prototype`：同上



#### instanceof 原理及实现

instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。



#### 5 Object.is()、`===`、`==`的区别

双等号会进行类型转换再判断

三等号不做类型转换，先判断类型

Object.is()一般与三等号相同，但对特殊值做了处理，如-0和+0不相等，两个NaN相等



#### 6 null和undefined的区别

undefined

- 表示未定义，就是变量声明了，但还未赋值。
- 它不是一个保留字，可以用作变量名，一般不建议这么做，如果想获得一个undefined值，可使用`void 0`这种方式

null

- 表示空对象，一般用来做为可能返回对象的变量的初始化值。null在使用typeof进行判断时会返回"object"



#### 7 NaN

`typeof NaN`返回number，但是它不等于自己

`isNaN`方法会尝试将参数转换为数值，任何不能被转换为数值的值都返回true，因此非数字值也会返回true，影响判断

`Number.isNaN()`函数会先判断参数是否为数字，不会对参数进行转换，对于NaN的判断更准确



#### 8 Map和Object的区别

- Map默认不包含任何键，只能显式插入键；Object原型链上的键名可能与自定义键名冲突。
- Map的键可以是任意值，包括函数、对象、基本类型；Object的键必须是String或Symbol
- Map中的key是有序的，按插入顺序；Object的键是无序的
- Map有size属性，Object键值个数只能手动计算
- Map可以被直接迭代，Object要以某种方式转换后才能迭代
- Map在频繁增删值的场景下表现更好



#### 9 Map和weakMap的区别

Map是键值对的集合，本质上是一个数组，它的每一个数据也是数组，它是一种更加完善的Hash结构。

weakMap也是键值对的集合，其中键是弱引用的，键必须是对象，原始数据类型不能做key，而值可以是任意值。它的目的是：有时想在某个对象上存放一些数据，但这会形成对这个对象的引用，不再需要这个对象时，必须手动删除，否则垃圾回收机制不会释放内存。而weakMap的键名是弱引用，即垃圾回收机制不将该引用考虑在内，只要不再被引用，会自动被清除。



#### 10 精度丢失/为什么0.1+0.2!==0.3，如何能相等

js中number类型遵循IEEE 754标准，使用64位浮点格式表示数字，也就是双精度浮点数，在二进制中，1符号位，11指数位，52尾数，就是说小数部分最多只保留52位，后面的位数就会被舍弃（0舍1入）。

这就导致了 js 不能精确表达所有的浮点数，而只能是一个近似值。

有些数在转换成二进制时会发生无限循环，多余的位数会被截断，造成精度丢失。



#### 11 类数组对象

拥有length属性和若干索引属性的对象，与数组类似，但不能调用数组的方法。常见的有arguments、DOM方法返回的结果、函数（它有length属性表示可接收参数个数）。



#### 12 类型转换方法

主要是指使用Number()、String()、Boolean()三个函数，手动将各种类型的值转换为目标类型

**转为字符串：**toString()方法不可转null、undefined，String()都能转

String()方法的规则：

1. 先调用对象自身的toString()方法，返回原始类型则对该值使用String()方法
2. 如果返回对象，再调用valueOf方法，如果返回原始类型的值，则使用该值的String函数
3. 如果valueOf返回对象，报错

具体转换：

- 数值：转为对应的字符串
- 字符串：原来的值
- 布尔值：true转为"true"，false转为"false"
- undefined：转为"undefined"
- null：转为"null"
- 对象：返回一个类型字符串
  - 对象：返回一个类型字符串，如：`String({a: 1}) // "[object Object]"`
  - 数组：返回数组的字符串形式，相当于调用Array.prototype.join()方法
  - Date：转为时间格式字符串

**转为数字：**Number()，比parseInt严格

具体转换：

- 数值：原来的值
- 字符串：如果可以被解析为数值，则转换为相应的值，空字符串转为0，否则返回NaN
- 布尔值：true转为1，false转为0
- undefined：转为NaN
- null：转为0
- 对象：
  - 对象：NaN
  - 数组：空数组转为0，只有一个元素时且可以转为数字时，对该元素使用Number()转换，其他均为NaN
  - Date：返回时间戳

**转为布尔值：**Boolean()

- 转为false：undefined、null、0（含-0和+0）、NaN、空字符串
- 其他情况全转为true



#### 13 相等==的转换规则

- 都是对象：两个对象都是同一引用返回true
- null和undefined：true
- 如果类型相同：
  - Number：+0==-0，NaN与任何值不相等
- 如果类型不同：
  - 数字与字符串：转为数字值
  - 如果有Boolean：转为1或0
  - 对象与数字/字符串：调用对象的valueOf()和toString()将对象转为原始值



#### 14 全等===的转换规则

- 类型不同返回false
- 都是对象：两个对象都是同一引用返回true
- 两个都为null或undefined，返回true
- 任意一个数为NaN，返回false
- 否则比较两个数的值：
  - 数字类型必须值相同，+0与-0相同



#### 15 关系运算符（<, >, <=, >=）转换规则

- 数据类型相同：
  - 都为字符串：按Unicode编码按顺序比较
  - 都为数值：按值比较
- 数据类型不同：
  - 含NaN：返回false
  - 一方为数值，另一方会转换为数值然后比较，否则为false
  - 一方为字符串，别一方转换为字符串后比较，否则为false
  - 如果有对象，则调用对象的valueOf()和toString()将对象转为原始值
  - 如果一方为布尔值，则会转换为数值



### 二、js基础

#### 1 原型、原型链

**prototype**和**`__proto__`**

每个函数都有一个 `prototype` 属性，它是函数在创建时由 js 引擎添加到函数上的，它的指向是一个对象，被称为**原型对象**或**原型**。

原型对象上包含了可以由该构造函数的所有实例共享的属性和方法。

对象包含一个 `[[Prototype]]` 属性（浏览器中通过`__proto__`可以访问，通过`Object.getPrototypeOf() `方法可以获取），它的指向是创建这个对象的构造函数的 `prototype`。

所以说，`obj.__proto__ === test.prototype`

**原型链**

因为对象的`__proto__`属性指向了“原型”对象，而这个“原型”对象又指向它自己的“原型”对象，这样递归下去，就形成了一个原型链。

原型链是 js 中一种实现继承的机制。当你访问一个对象的属性时，如果对象自身没有这个属性，那么就会沿着原型链查找这个属性，直到找到为止或者到达原型链的末尾。

所以说，原型对象上的属性和方法可以由该函数的所有实例共享。

原型链的终点是null。

**函数与对象的关系**

函数是一种特殊的对象，它有一个特殊的功能，就是可以被调用（执行）。当一个函数被用作构造函数来创建对象时，这个函数就被称为构造函数。

在 js 中，所有的对象都是由函数创建的：

- 实例对象通过 new 关键字显式调用构造函数来创建
- 字面量对象虽然没有显示的调用构造函数，实际上也是 js 解释器通过` let xx=new Object()` 来创建的

**构造函数与普通函数**

在写法上：

- 构造函数通常以大写字母开头，以区别于普通函数
- 构建函数使用 new 关键字来创建新的对象实例

使用目的上：

- 构造函数主要用于创建和初始化一个对象
- 普通函数通常用于执行特定的任务或计算并返回结果



#### 2 `new`操作符的实现过程

1. 在当前函数作用域内在中创建一个新的空对象，即`{}`
2. 为这个对象添加`__proto__`属性，让它指向构造函数的原型对象，并为原型对象指定constructor属性，指向构造函数
3. 调用`apply`或`call`方法，切换上下文，执行构造函数方法，为对象添加其他属性
4. 返回这个对象，

```js
//Fun为构造函数, args表示传参
function myNew(Fun, ...args) {
    // 1.在内存中创建一个新对象
    let obj = {};
    
    // 2.把新对象的原型指针指向构造函数的原型属性
    obj.__proto__ = Fun.prototype;
    
    // 3.改变this指向，并且执行构造函数内部的代码（传参）
    let res = Fun.apply(obj, args);
    
    // 4.判断函数执行结果的类型
    if (res instanceof Object) {
        return res;
    } else {
        return obj;
    }
}

function One(name, age) {
    this.name = name;
    this.age = age;
}
let a = new One();
console.log(a);


let obj = myNew(One, "XiaoMing", "18");
console.log("newObj:", obj);
```



#### 3 this

this 并不是一个好的设计，它会随着作用域不同而变化。

this代表函数调用相关联的对象，通常叫做函数上下文

1、函数调用模式

在全局作用域或函数外部使用this，它指向全局对象。非严格模式下指向全局对象（在浏览器中，全局对象是window，在 nodejs 中，全局对象是 global），严格模式下是undefined

```js
console.log(this); // window
```

2、方法调用时

在函数内部使用this，它的值取决于函数如何被调用。如果函数是作为一个方法被调用的，那么this就指向调用该方法的对象

```js
let obj = {
  name: 'John',
  sayHello: function() {
    console.log('Hello, ' + this.name);
  }
};

obj.sayHello(); // Hello, John
```

在这个例子中，sayHello方法内的this指向obj对象。

3、构造器调用模式

在构造函数中使用this，它指向新创建的对象实例。

```js
function Person(name) {
  this.name = name;
}

let john = new Person('John');
console.log(john.name); // John
```

在这个例子中，Person构造函数中的this指向新创建的对象john。

4、apply/call/bind 调用模式

当函数使用call、apply或bind方法被调用时，this指向传递给这些方法的第一个参数

```js
function sayHello() {
  console.log('Hello, ' + this.name);
}

let john = { name: 'John' };
let jane = { name: 'Jane' };

sayHello.call(john); // Hello, John
sayHello.call(jane); // Hello, Jane
```

在这个例子中，sayHello函数中的this分别指向john和jane对象。

5、箭头函数中

箭头函数中使用this，指向定义函数时的父级作用域的 this，且无法被改变

```js
let obj = {
  name: 'John',
  sayHello: function() {
    setTimeout(() => {
      console.log('Hello, ' + this.name);
    }, 1000);
  }
};

obj.sayHello(); // Hello, John
```

优先级：

构造器调用 > apply/call/bind > 方法调用 > 函数调用



#### 2 作用域、作用域链

作用域是可访问变量的集合，在 js 中对象和函数同样是变量，作用域为可访问变量、对象、函数的集合。

变量的作用域指的是该变量的可访问区域，一个变量只能在其所处的作用域内被访问，在作用域外是不可见的。

作用域是一个存放变量的独立空间，它们之间可以相互嵌套，形成引用关系，这条链叫做作用域链。

- 全局作用域：代码中任何地方都能访问到的对象，拥有全局作用域，如：最外层变量和函数，未使用var声明的变量，window对象上的属性和函数
- 函数作用域：声明在函数内部的变量，在函数体内始终可见，包括函数的形参。函数调用时创建一个函数作用域。
- 块级作用域：es6新增，通过let、const声明，如：函数内部、一个代码块内部（由一对`{}`包裹）



#### 3 constructor/构造器

每个函数在创建时都有一个prototype属性指向其原型对象，默认情况下，所有原型对象都会获得一个constructor的属性，指向prototype属性所在的函数。当调用构造函数创建一个新实例，该实例的内部将包含一个继承自构造函数的`__proto__`属性，指向构造函数的原型对象。

构造函数的prototype属性被重写时，constructor不再指向其构造函数。





#### 5 原生js中实现继承的方式

- 单独使用原型链：
  - 思路：把实例的原型指向另一个对象，在实例和原型之间形成一条链。
  - 问题：（1）不同实例间的引用类型属性会共享；（2）子类型在实例化时不能给父类型的构造函数传参
- 盗用构造函数：
  - 思路：通过`call`或`apply`方法，在子类构造函数中调用父类构造函数，解决不能给父类型传参的问题；
  - 问题：构造函数中的方法定义不能重用，也不能访问父类原型上定义的方法。
- 组合继承（常用）：
  - 思路：使用原型链继承原型上的属性和方法，通过盗用构造函数继承实例属性
  - 问题：效率不高，父类构造函数始终会被调用2次，一次在创建子类原型时调用，一次在子类构造函数中调用
- 原型式继承：`Object.create()`
  - 思路：创建一个临时构造函数，将传入的对象副本（浅复制）赋值给这个构造函数的原型，然后用这个临时类型创建实例。
  - 问题：属性中包含的引用值始终会在相关对象间共享
- 寄生式继承：
  - 思路：创建一个实现继承的函数，以某种方式增强这个函数的实例对象，然后返回这个对象
  - 问题：给对象添加函数会导致函数难以重用，与构造函数模式类似
- 寄生式组合继承：（最佳）
  - 思路：以寄生式的方式取得父类原型的副本，然后将子类的构造函数设置为这个副本



#### 7 闭包

**闭包的核心作用：让变量驻留在内存，不被回收。**正常的函数在执行完后，内部的局部变量就被释放了，而当函数内部的局部变量一直被引用时，不会被回收。

形成闭包的关键点在于：1）外层函数与内层函数形成嵌套，同时把内部函数 return 出去； 2）内层函数使用了外层函数的局部变量。

这样在调用函数时，执行的是内层函数，但是它还引用了外层函数的局部变量，当变量一直被引用时，不会被回收。

```js
function fn(){
  let a=10;
  function(){
    a++;
    console.log(a)
  }
}

fn();
fn();
fn();
```

而像其他的所谓的闭包的特点：

- 外部函数可以访问内部函数的作用域；
- 局部变量会常驻在内存中
- 可以避免全局变量，防止全局变量污染

这些对普通函数也是可以的，并不算是闭包的特殊之处。



#### 内存泄漏

- 意外的全局变量：
- 未清除的定时器（setInterval）或回调函数
- 脱离 DOM 的引用：比如获取了一个 DOM 元素的引用，后面元素被删除，但这个引用一直被保留。
- 闭包



#### 8 arguments

在调用有参数的函数时，js会把所传的参数保存在arguments对象里，它是个类数组数据。它不能显示的创建，只有函数中可用。

作用：可以不用给函数设定形参，而动态的通过arguments为函数加入参数。



#### 9 let、const、var的区别

- let、const具有块级作用域，var没有
- var声明的变量可以重复声明，const、let不允许
- 暂时性死区：由于const、let不存在变量提升，所以在声明前使用变量会报错，形成暂时性死区。var可以提升变量，所以没有。
- 初始值设置：var、let可以没有初值，const必须设置初始值
- 指针指向：let创建的变量可以更改指针指向，即重新赋值。const不允许，它保证指针的指向的内存地址不变，对于基本类型值就在内存地址，对引用类型变量指向内存地址，只要地址不变，就代表值没变



#### 10 箭头函数

箭头函数的语法比函数表达式语法简洁，没有自己的this、arguments、super、new.target。更适用于本为需要匿名函数的地方，并且它不能做构造函数。

箭头函数的优点：

- 箭头函数书写简洁：一个参数时可省略小括号，函数体只有一个返回语句时可省略大括号
- 箭头函数没有自己的this，它只会在自己作用域的上一层继承this，所以箭头函数在定义时已经确定了this指向，不会改变
- 箭头函数没有prototype，所以不能作为构造函数使用
- 箭头函数没有自己的arguments，在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。可以使用rest参数代替argrments来访问参数列表
- 不能用作Generator函数，不能使用yeild关键字

**箭头函数的 this**

普通函数的 this 取决于调用，也就是说谁调用函数，this 的指向就指向谁。

箭头函数的 this 取决于定义环境，也就是说在定义时，它从外层环境中去继承 this

```
let fn=()=> console.log(this)

fn();
```



#### Promise

异步编程的一种解决方案，解决了回调地狱的问题

它是一个对象，也可以理解为一个容器，它可以获取异步操作的消息。

Promise 的实例有 3 个状态：Pending 进行中，Resolved 已完成，Rejected 已拒绝，它的状态只能从 pending->fulfilled:Resolved或 pending->rejected:Rejected。

优点：

有了 Promise 对象（对象可以保存状态，函数不可以，除了闭包），可以将异步操作以同步的流程表达出来，避免了回调地狱。提供了统一的接口，使得控制异步操作更加容易。

缺点：

无法取消 Promise，一旦创建就会立即执行；如果不设置回调函数，Promise 内部的错误不会反应到外部；当处理pending 状态时，无法得知具体进展到哪一步（刚开始还是即将完成）

**原型方法**

then()、catch()、finally()

**常用方法**

Promise.all：同时执行多个 promise 实例，包装成一个新的 Promise 实例。有任何一个失败则该 Promise 失败，返回第一个失败的子 Promise 的结果。

Promise.race：任意一个promise被拒绝或者成功，则会采用第一个promise作为他的返回值。

Promise.any：任意一个完成时就会终止，会忽略所有被拒绝掉的promise，直到第一个promise完成

Promise.allSettled：所有promise被拒绝后会返回一个拒绝的promise数组



#### 11 async/await

async/await也是异步编程的解决方案，是基于generator函数对promise封装的语法糖，它内置执行器，不需要额外的调用直接会自动执行并输出结果。

async 函数返回的是一个 Promise对象，如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve()封装成 Promise 对象。

对比 Promise 的优势：

- 避免 then的链式调用带来的可读性问题
- Promise 传递中间值不方便，而 async/await 是同步写法，传递中间值非常优雅
- 错误处理友好，可以使用 try/catch
- 调试友好

适用场景：

处理多个 Promise 组成的then 链。比如多个步骤，每个步骤都是异步，且依赖于上一个步骤的结果。



#### 12 深拷贝与浅拷贝

js中引用数据类型在堆中保存真实的值，在栈中保存了指向真实值的指针，因此使用=赋值时，只是对指针进行了复制，这样称为浅拷贝；如果通过某种方式将引用数据类型堆内存中的值拷贝给另一个引用类型，称为深拷贝。

深拷贝与浅拷贝主要就是针对引用类型数据。

深拷贝方式：

- JSON.stringify和JSON.parse，可以实现嵌套对象的拷贝，可以深拷贝数组和对象，但不能拷贝函数
- 扩展运算符或Object.assign，只能对一层引用对象进行深拷贝
- 手写递归深拷贝函数



#### 13 Object.assign和扩展运算符

两者都是浅拷贝，

- Object.assign会把源对象的可枚举属性复制到目标对象中，如果重名会覆盖；
- 扩展运算符把数组或对象中的每个值拷贝到一个新的数组或对象，不复制继承的属性，但会复制Symbol属性



#### 14 Proxy

使用方式：`let p=new Proxy(target,handler)`，所有用法都是这种形式，不同的只是handler参数的写法

它的优势就是可以监听整个对象，不需要层层递归为每个属性添加代理，性能上更好，缺点是兼容性。



#### 15 apply、call、bind

作用相同 

apply 接受2 个参数，第一个参数指定函数体内 this 的指向，第二个参数是一个数组/类数组，用于接收参数

call 接收参数数量不固定，第一个参数同上，后续的参数被依次传入函数



#### Object.is()与“==”、“===”

双等号进行相等判断时，如果类型不一致，会进行强制类型转换后再比较

三等号在类型不一致时不会强制类型转换，直接返回 false

Object.is()一般情况下与三等号行为一致，处理了一些特殊情况：-0 和+0 不相等，NaN 相等



#### 尾调用优化

指某个函数的最后一步是调用另一个函数。

函数调用会在内存形成一个"调用记录"，又称"调用帧"（call frame），保存调用位置和内部变量等信息。

如果在函数A的内部调用函数B，那么在A的调用记录上方，还会形成一个B的调用记录。等到B运行结束，将结果返回到A，B的调用记录才会消失。如果函数B内部还调用函数C，那就还有一个C的调用记录栈，以此类推。所有的调用记录，就形成一个["调用栈"](https://zh.wikipedia.org/wiki/调用栈)（call stack）。

尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。

使用尾调用的话，因为已经是函数的最后一步，所以这时可以不再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。



#### for...in 和 for...of

for...of：

- es6 新增，允许遍历实现了 Iterator 接口的数据结构，如 Map、Set、数组、对象、类数组对象、字符串、Generator 对象
- 遍历时获取的是对象的键值
- 只遍历当前对象
- 对数组遍历只返回数组的下标对应的属性值

for...in：

- es3 中的方法，获取对象的键名
- 会遍历对象的整个原型链，性能差
- 对数组遍历会返回所有可枚举属性，包含原型链上的



#### fetch

es6 中出现的原生 js 语法，ajax 的替代品，基于 Promise 对象封装，代码结构简单。

优点：

- 语法简洁，更加语义化
- 基于 Promise 实现，支持 async/await
- 更加底层，提供了丰富的 api，如 request、response

缺点：

- 只对网络请求报错，对 400、500都当作成功的请求
- 默认不带 cookie，需要添加配置项：`fetch(url,{credentials:'include'})`
- 不支持 abort，不支持超时控制
- 不能原生监测请求的进度，xhr 可以



#### 异步编程的实现

js 中的异步机制有以下几种：

**回调函数：**

缺点是多个回调函数嵌套时会造成回调地狱，回调函数间耦合度高，不利于维护

**Promise 方式：**

将嵌套的回调函数使用 then 方法作为链式调用，但是可能造成代码语义不明确

**generator 方式：**

通过转移函数的执行权实现，当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再转移回来。此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如 说 co 模块等方式来实现 generator 的自动执行。

**async 函数方式：**

async 是 generator 和 promise 实现的一个自动执行的语法糖，内部自带执行器，当函数内部执行到 await 语句时，如果语句返回一个 promise 对象，则函数会等待它的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑转化为同步的顺序来书写，并且这个函数可以自动执行。



#### 对象创建的方式

**字面量的形式直接创建对象**，创建大量相似对象时，会产生大量的重复代码

1. 工厂模式：用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。缺点：它只是简单的封装了复用代码，无法和某个类型联系起来，没有建立对象和类型间的关系。
2. 构造函数模式：即通过 `new Function()`的方式创建，新建的对象与原型通过 prototype 建立了联系。缺点：造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，每次都会新建一个函数对象，浪费内存，国灰函数是所有的实例都可以通用的。
3. 原型模式：每个函数都有一个 prototype 属性，用来指向原型对象，因此可以使用原型对象来添加公共属性和方法，实现代码复用。缺点：不能通过传入参数来初始化值；如果存在引用类型的值，那么所有实例将共享一个对象。
4. 组合构造函数模式+原型模式：创建自定义类型最常见的方式，通过构造函数初始化对象的属性，通过原型对象实现函数方法的复用。缺点：由于使用了两种不同的模式，代码的封装性不够好。
5. 动态原型模式：将原型方法赋值的创建过程移动到构造函数内部，通过判断属性是否存在，可以实现仅在第一次调用函数时对原型对象赋值一次的效果，这种方式很好的对上面的混合模式进行了封装
6. 寄生构造函数模式：与工厂模式基本相同，主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展，这样既不用修改原来的构造函数，也扩展了对象。



#### 对象继承的方式

1. 原型链方式：通过原型链实现继承，缺点：在包含引用类型时，会被所有实例对象共享，造成数据混乱；创建子类型时不能向父类型传参
2. 借用构造函数的方式：通过在子类型的函数中调用超类型的构造函数来解决向超类型传参的问题，但它无法实现函数方法的复用，并且超类型原型定义的方法子类型也访问不到。
3. 组合继承：将原型链和借用构造函数组合使用，通过借用构造函数来实现类型的属性继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。缺点：由于是以超类型的实例来作为子类型的原型，所以调用了两次超类型的构造函数，造成子类型的原型中增加了不必要的属性。
4. 原型式继承：基于已有的对象来创建新的对象，原理是，向函数中传入一个对象，然后返回一个以该对象为原型的对象。这种思路主要是对某个对象实现一种简单继承，Object.create()就是原型式继承的实现。缺点与原型链方式相同
5. 寄生式继承：创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本， 然后对象进行扩展，最后返回这个对象。**优点**：对一个简单对象实现继承，如果这个对象不是自定义类型时。**缺点**是没有办法实现函数的复用
6. 寄生式组合继承：组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。



#### 内存管理

**生命周期**

分配内存，使用内存，释放内存

**内存限制**

64 位系统约 1.4GB，32 位约为 0.7GB

**内存分配**

栈：存放基本数据类型（静态数据）直接在栈空间内分配，引擎知道数据的大小，所以会分配固定数量的内存；包括：string、number、boolean、undefined、null、指向对象和函数的引用

堆：引用数据类型（动态数据）在堆内存中开辟空间，并将该空间的指针存储在栈中，变量指向的是堆内存的地址。

池：一般也归类栈中，一般存放常量，也叫常量池。

特殊的：闭包中的变量是在堆内存中的。

字符串常量池：字符串存在字符串常量池中，被栈或堆上的变量引用。如果变量的值是字符串字面量，则在栈上的变量直接引用字符串常量池中的字符串；如果是字符串是 new String 创建的，则会在堆上创建 String 对象，指向字符串常量池中的字符串，栈上变量指向堆中的 String 对象。



**内存回收**

常用的：

- 引用计数法：看一个对象是否有指向它的引用。用法简单，但是是存在循环引用的问题，会导致内存泄露，所以不再使用
- 标记清除法：它通过从根对象（如全局对象和当前执行上下文的变量）开始，标记所有可以访问的对象，然后清除未标记的对象。这样，不可访问的对象就会被释放并回收内存。标记清除算法能够处理循环引用，并且只回收不再被引用的对象。

v8 的 GC

基于分代式垃圾回收机制，新生代的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。

新生代主要通过Scavenge算法
