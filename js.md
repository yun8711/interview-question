[TOC]









#### 2 作用域、作用域链

作用域是可访问变量的集合，在 js 中对象和函数同样是变量，作用域为可访问变量、对象、函数的集合。

变量的作用域指的是该变量的可访问区域，一个变量只能在其所处的作用域内被访问，在作用域外是不可见的。

作用域是一个存放变量的独立空间，它们之间可以相互嵌套，形成引用关系，这条链叫做作用域链。

- 全局作用域：代码中任何地方都能访问到的对象，拥有全局作用域，如：最外层变量和函数，未使用var声明的变量，window对象上的属性和函数
- 函数作用域：声明在函数内部的变量，在函数体内始终可见，包括函数的形参。函数调用时创建一个函数作用域。
- 块级作用域：es6新增，通过let、const声明，如：函数内部、一个代码块内部（由一对`{}`包裹）





#### 5 原生js中实现继承的方式

- 单独使用原型链：
  - 思路：把实例的原型指向另一个对象，在实例和原型之间形成一条链。
  - 问题：（1）不同实例间的引用类型属性会共享；（2）子类型在实例化时不能给父类型的构造函数传参
- 盗用构造函数：
  - 思路：通过`call`或`apply`方法，在子类构造函数中调用父类构造函数，解决不能给父类型传参的问题；
  - 问题：构造函数中的方法定义不能重用，也不能访问父类原型上定义的方法。
- 组合继承（常用）：
  - 思路：使用原型链继承原型上的属性和方法，通过盗用构造函数继承实例属性
  - 问题：效率不高，父类构造函数始终会被调用2次，一次在创建子类原型时调用，一次在子类构造函数中调用
- 原型式继承：`Object.create()`
  - 思路：创建一个临时构造函数，将传入的对象副本（浅复制）赋值给这个构造函数的原型，然后用这个临时类型创建实例。
  - 问题：属性中包含的引用值始终会在相关对象间共享
- 寄生式继承：
  - 思路：创建一个实现继承的函数，以某种方式增强这个函数的实例对象，然后返回这个对象
  - 问题：给对象添加函数会导致函数难以重用，与构造函数模式类似
- 寄生式组合继承：（最佳）
  - 思路：以寄生式的方式取得父类原型的副本，然后将子类的构造函数设置为这个副本



#### 7 闭包

**闭包的核心作用：让变量驻留在内存，不被回收。**正常的函数在执行完后，内部的局部变量就被释放了，而当函数内部的局部变量一直被引用时，不会被回收。

形成闭包的关键点在于：1）外层函数与内层函数形成嵌套，同时把内部函数 return 出去； 2）内层函数使用了外层函数的局部变量。

这样在调用函数时，执行的是内层函数，但是它还引用了外层函数的局部变量，当变量一直被引用时，不会被回收。

```js
function fn(){
  let a=10;
  function(){
    a++;
    console.log(a)
  }
}

fn();
fn();
fn();
```

而像其他的所谓的闭包的特点：

- 外部函数可以访问内部函数的作用域；
- 局部变量会常驻在内存中
- 可以避免全局变量，防止全局变量污染

这些对普通函数也是可以的，并不算是闭包的特殊之处。



#### 内存泄漏

- 意外的全局变量：
- 未清除的定时器（setInterval）或回调函数
- 脱离 DOM 的引用：比如获取了一个 DOM 元素的引用，后面元素被删除，但这个引用一直被保留。
- 闭包



#### 8 arguments

在调用有参数的函数时，js会把所传的参数保存在arguments对象里，它是个类数组数据。它不能显示的创建，只有函数中可用。

作用：可以不用给函数设定形参，而动态的通过arguments为函数加入参数。



#### 9 let、const、var的区别

- let、const具有块级作用域，var没有
- var声明的变量可以重复声明，const、let不允许
- 暂时性死区：由于const、let不存在变量提升，所以在声明前使用变量会报错，形成暂时性死区。var可以提升变量，所以没有。
- 初始值设置：var、let可以没有初值，const必须设置初始值
- 指针指向：let创建的变量可以更改指针指向，即重新赋值。const不允许，它保证指针的指向的内存地址不变，对于基本类型值就在内存地址，对引用类型变量指向内存地址，只要地址不变，就代表值没变



#### 10 箭头函数

箭头函数的语法比函数表达式语法简洁，没有自己的this、arguments、super、new.target。更适用于本为需要匿名函数的地方，并且它不能做构造函数。

箭头函数的优点：

- 箭头函数书写简洁：一个参数时可省略小括号，函数体只有一个返回语句时可省略大括号
- 箭头函数没有自己的this，它只会在自己作用域的上一层继承this，所以箭头函数在定义时已经确定了this指向，不会改变
- 箭头函数没有prototype，所以不能作为构造函数使用
- 箭头函数没有自己的arguments，在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。可以使用rest参数代替argrments来访问参数列表
- 不能用作Generator函数，不能使用yeild关键字

**箭头函数的 this**

普通函数的 this 取决于调用，也就是说谁调用函数，this 的指向就指向谁。

箭头函数的 this 取决于定义环境，也就是说在定义时，它从外层环境中去继承 this

```
let fn=()=> console.log(this)

fn();
```



#### Promise

异步编程的一种解决方案，解决了回调地狱的问题

它是一个对象，也可以理解为一个容器，它可以获取异步操作的消息。

Promise 的实例有 3 个状态：Pending 进行中，Resolved 已完成，Rejected 已拒绝，它的状态只能从 pending->fulfilled:Resolved或 pending->rejected:Rejected。

优点：

有了 Promise 对象（对象可以保存状态，函数不可以，除了闭包），可以将异步操作以同步的流程表达出来，避免了回调地狱。提供了统一的接口，使得控制异步操作更加容易。

缺点：

无法取消 Promise，一旦创建就会立即执行；如果不设置回调函数，Promise 内部的错误不会反应到外部；当处理pending 状态时，无法得知具体进展到哪一步（刚开始还是即将完成）

**原型方法**

then()、catch()、finally()

**常用方法**

Promise.all：同时执行多个 promise 实例，包装成一个新的 Promise 实例。有任何一个失败则该 Promise 失败，返回第一个失败的子 Promise 的结果。

Promise.race：任意一个promise被拒绝或者成功，则会采用第一个promise作为他的返回值。

Promise.any：任意一个完成时就会终止，会忽略所有被拒绝掉的promise，直到第一个promise完成

Promise.allSettled：所有promise被拒绝后会返回一个拒绝的promise数组



#### 11 async/await

async/await也是异步编程的解决方案，是基于generator函数对promise封装的语法糖，它内置执行器，不需要额外的调用直接会自动执行并输出结果。

async 函数返回的是一个 Promise对象，如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve()封装成 Promise 对象。

对比 Promise 的优势：

- 避免 then的链式调用带来的可读性问题
- Promise 传递中间值不方便，而 async/await 是同步写法，传递中间值非常优雅
- 错误处理友好，可以使用 try/catch
- 调试友好

适用场景：

处理多个 Promise 组成的then 链。比如多个步骤，每个步骤都是异步，且依赖于上一个步骤的结果。



#### 12 深拷贝与浅拷贝

js中引用数据类型在堆中保存真实的值，在栈中保存了指向真实值的指针，因此使用=赋值时，只是对指针进行了复制，这样称为浅拷贝；如果通过某种方式将引用数据类型堆内存中的值拷贝给另一个引用类型，称为深拷贝。

深拷贝与浅拷贝主要就是针对引用类型数据。

深拷贝方式：

- JSON.stringify和JSON.parse，可以实现嵌套对象的拷贝，可以深拷贝数组和对象，但不能拷贝函数
- 扩展运算符或Object.assign，只能对一层引用对象进行深拷贝
- 手写递归深拷贝函数



#### 13 Object.assign和扩展运算符

两者都是浅拷贝，

- Object.assign会把源对象的可枚举属性复制到目标对象中，如果重名会覆盖；
- 扩展运算符把数组或对象中的每个值拷贝到一个新的数组或对象，不复制继承的属性，但会复制Symbol属性



#### 14 Proxy

使用方式：`let p=new Proxy(target,handler)`，所有用法都是这种形式，不同的只是handler参数的写法

它的优势就是可以监听整个对象，不需要层层递归为每个属性添加代理，性能上更好，缺点是兼容性。



#### 15 apply、call、bind

作用相同 

apply 接受2 个参数，第一个参数指定函数体内 this 的指向，第二个参数是一个数组/类数组，用于接收参数

call 接收参数数量不固定，第一个参数同上，后续的参数被依次传入函数



#### 尾调用优化

指某个函数的最后一步是调用另一个函数。

函数调用会在内存形成一个"调用记录"，又称"调用帧"（call frame），保存调用位置和内部变量等信息。

如果在函数A的内部调用函数B，那么在A的调用记录上方，还会形成一个B的调用记录。等到B运行结束，将结果返回到A，B的调用记录才会消失。如果函数B内部还调用函数C，那就还有一个C的调用记录栈，以此类推。所有的调用记录，就形成一个["调用栈"](https://zh.wikipedia.org/wiki/调用栈)（call stack）。

尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。

使用尾调用的话，因为已经是函数的最后一步，所以这时可以不再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。



#### for...in 和 for...of

for...of：

- es6 新增，允许遍历实现了 Iterator 接口的数据结构，如 Map、Set、数组、对象、类数组对象、字符串、Generator 对象
- 遍历时获取的是对象的键值
- 只遍历当前对象
- 对数组遍历只返回数组的下标对应的属性值

for...in：

- es3 中的方法，获取对象的键名
- 会遍历对象的整个原型链，性能差
- 对数组遍历会返回所有可枚举属性，包含原型链上的



#### fetch

es6 中出现的原生 js 语法，ajax 的替代品，基于 Promise 对象封装，代码结构简单。

优点：

- 语法简洁，更加语义化
- 基于 Promise 实现，支持 async/await
- 更加底层，提供了丰富的 api，如 request、response

缺点：

- 只对网络请求报错，对 400、500都当作成功的请求
- 默认不带 cookie，需要添加配置项：`fetch(url,{credentials:'include'})`
- 不支持 abort，不支持超时控制
- 不能原生监测请求的进度，xhr 可以



#### 异步编程的实现

js 中的异步机制有以下几种：

**回调函数：**

缺点是多个回调函数嵌套时会造成回调地狱，回调函数间耦合度高，不利于维护

**Promise 方式：**

将嵌套的回调函数使用 then 方法作为链式调用，但是可能造成代码语义不明确

**generator 方式：**

通过转移函数的执行权实现，当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再转移回来。此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如 说 co 模块等方式来实现 generator 的自动执行。

**async 函数方式：**

async 是 generator 和 promise 实现的一个自动执行的语法糖，内部自带执行器，当函数内部执行到 await 语句时，如果语句返回一个 promise 对象，则函数会等待它的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑转化为同步的顺序来书写，并且这个函数可以自动执行。



#### 对象创建的方式

**字面量的形式直接创建对象**，创建大量相似对象时，会产生大量的重复代码

1. 工厂模式：用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。缺点：它只是简单的封装了复用代码，无法和某个类型联系起来，没有建立对象和类型间的关系。
2. 构造函数模式：即通过 `new Function()`的方式创建，新建的对象与原型通过 prototype 建立了联系。缺点：造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，每次都会新建一个函数对象，浪费内存，国灰函数是所有的实例都可以通用的。
3. 原型模式：每个函数都有一个 prototype 属性，用来指向原型对象，因此可以使用原型对象来添加公共属性和方法，实现代码复用。缺点：不能通过传入参数来初始化值；如果存在引用类型的值，那么所有实例将共享一个对象。
4. 组合构造函数模式+原型模式：创建自定义类型最常见的方式，通过构造函数初始化对象的属性，通过原型对象实现函数方法的复用。缺点：由于使用了两种不同的模式，代码的封装性不够好。
5. 动态原型模式：将原型方法赋值的创建过程移动到构造函数内部，通过判断属性是否存在，可以实现仅在第一次调用函数时对原型对象赋值一次的效果，这种方式很好的对上面的混合模式进行了封装
6. 寄生构造函数模式：与工厂模式基本相同，主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展，这样既不用修改原来的构造函数，也扩展了对象。



#### 对象继承的方式

1. 原型链方式：通过原型链实现继承，缺点：在包含引用类型时，会被所有实例对象共享，造成数据混乱；创建子类型时不能向父类型传参
2. 借用构造函数的方式：通过在子类型的函数中调用超类型的构造函数来解决向超类型传参的问题，但它无法实现函数方法的复用，并且超类型原型定义的方法子类型也访问不到。
3. 组合继承：将原型链和借用构造函数组合使用，通过借用构造函数来实现类型的属性继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。缺点：由于是以超类型的实例来作为子类型的原型，所以调用了两次超类型的构造函数，造成子类型的原型中增加了不必要的属性。
4. 原型式继承：基于已有的对象来创建新的对象，原理是，向函数中传入一个对象，然后返回一个以该对象为原型的对象。这种思路主要是对某个对象实现一种简单继承，Object.create()就是原型式继承的实现。缺点与原型链方式相同
5. 寄生式继承：创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本， 然后对象进行扩展，最后返回这个对象。**优点**：对一个简单对象实现继承，如果这个对象不是自定义类型时。**缺点**是没有办法实现函数的复用
6. 寄生式组合继承：组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。



#### 内存管理

**生命周期**

分配内存，使用内存，释放内存

**内存限制**

64 位系统约 1.4GB，32 位约为 0.7GB

**内存分配**

栈：存放基本数据类型（静态数据）直接在栈空间内分配，引擎知道数据的大小，所以会分配固定数量的内存；包括：string、number、boolean、undefined、null、指向对象和函数的引用

堆：引用数据类型（动态数据）在堆内存中开辟空间，并将该空间的指针存储在栈中，变量指向的是堆内存的地址。

池：一般也归类栈中，一般存放常量，也叫常量池。

特殊的：闭包中的变量是在堆内存中的。

字符串常量池：字符串存在字符串常量池中，被栈或堆上的变量引用。如果变量的值是字符串字面量，则在栈上的变量直接引用字符串常量池中的字符串；如果是字符串是 new String 创建的，则会在堆上创建 String 对象，指向字符串常量池中的字符串，栈上变量指向堆中的 String 对象。



**内存回收**

常用的：

- 引用计数法：看一个对象是否有指向它的引用。用法简单，但是是存在循环引用的问题，会导致内存泄露，所以不再使用
- 标记清除法：它通过从根对象（如全局对象和当前执行上下文的变量）开始，标记所有可以访问的对象，然后清除未标记的对象。这样，不可访问的对象就会被释放并回收内存。标记清除算法能够处理循环引用，并且只回收不再被引用的对象。

v8 的 GC

基于分代式垃圾回收机制，新生代的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。

新生代主要通过Scavenge算法
