import{_ as s,S as a,N as n,Q as l}from"./chunks/framework.d2ce16e8.js";const A=JSON.parse('{"title":"js 基础","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"docs/js-basic.md","filePath":"docs/js-basic.md","lastUpdated":1708601980000}'),p={name:"docs/js-basic.md"},o=l(`<h1 id="js-基础" tabindex="-1">js 基础 <a class="header-anchor" href="#js-基础" aria-label="Permalink to &quot;js 基础&quot;">​</a></h1><h2 id="核心知识" tabindex="-1">核心知识 <a class="header-anchor" href="#核心知识" aria-label="Permalink to &quot;核心知识&quot;">​</a></h2><h3 id="原型、原型链" tabindex="-1">原型、原型链 <a class="header-anchor" href="#原型、原型链" aria-label="Permalink to &quot;原型、原型链&quot;">​</a></h3><p>1、**prototype **和 <code>__proto__</code></p><p>每个函数都有一个 <code>prototype</code> 属性，它是函数在创建时由 js 引擎添加到函数上的，它的指向是一个对象，被称为<strong>原型对象</strong>或<strong>原型</strong>。</p><p>原型对象上包含了可以由该构造函数的所有实例共享的属性和方法。</p><p>对象包含一个 <code>[[Prototype]]</code> 属性（浏览器中通过<code>__proto__</code>可以访问，通过<code>Object.getPrototypeOf() </code>方法可以获取），它的指向是创建这个对象的构造函数的 <code>prototype</code>。</p><p>所以说，<code>obj.__proto__ === test.prototype</code></p><p>2、<strong>原型链</strong></p><p>因为对象的<code>__proto__</code>属性指向了“原型”对象，而这个“原型”对象又指向它自己的“原型”对象，这样递归下去，就形成了一个原型链。</p><p>原型链是 js 中一种实现继承的机制。当你访问一个对象的属性时，如果对象自身没有这个属性，那么就会沿着原型链查找这个属性，直到找到为止或者到达原型链的末尾。</p><p>所以说，原型对象上的属性和方法可以由该函数的所有实例共享。</p><p>原型链的终点是null。</p><p>3、<strong>函数与对象的关系</strong></p><p>函数是一种特殊的对象，它有一个特殊的功能，就是可以被调用（执行）。当一个函数被用作构造函数来创建对象时，这个函数就被称为构造函数。</p><p>在 js 中，所有的对象都是由函数创建的：</p><ul><li>实例对象通过 new 关键字显式调用构造函数来创建</li><li>字面量对象虽然没有显示的调用构造函数，实际上也是 js 解释器通过<code> let xx=new Object()</code> 来创建的</li></ul><p>4、<strong>构造函数与普通函数</strong></p><p>在写法上：</p><ul><li>构造函数通常以大写字母开头，以区别于普通函数</li><li>构建函数使用 new 关键字来创建新的对象实例</li></ul><p>使用目的上：</p><ul><li>构造函数主要用于创建和初始化一个对象</li><li>普通函数通常用于执行特定的任务或计算并返回结果</li></ul><br><h3 id="new操作符的实现过程" tabindex="-1"><code>new</code>操作符的实现过程 <a class="header-anchor" href="#new操作符的实现过程" aria-label="Permalink to &quot;\`new\`操作符的实现过程&quot;">​</a></h3><ol><li>在当前函数作用域内在中创建一个新的空对象，即<code>{}</code></li><li>为这个对象添加<code>__proto__</code>属性，让它指向构造函数的原型对象，并为原型对象指定constructor属性，指向构造函数</li><li>调用<code>apply</code>或<code>call</code>方法，切换上下文，执行构造函数方法，为对象添加其他属性</li><li>返回这个对象，</li></ol><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">//Fun为构造函数, args表示传参</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">myNew</span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">Fun</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">...</span><span style="color:#BABED8;font-style:italic;">args</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 1.在内存中创建一个新对象</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">obj</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{};</span></span>
<span class="line"><span style="color:#F07178;">    </span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 2.把新对象的原型指针指向构造函数的原型属性</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#BABED8;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">__proto__</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">Fun</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">prototype</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 3.改变this指向，并且执行构造函数内部的代码（传参）</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">res</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">Fun</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">apply</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">obj</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">args</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 4.判断函数执行结果的类型</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#BABED8;">res</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">instanceof</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">Object</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">res</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">obj</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">One</span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">name</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">age</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#BABED8;">name</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">name</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#BABED8;">age</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">age</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#BABED8;"> a </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">new</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">One</span><span style="color:#BABED8;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(a)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#BABED8;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">myNew</span><span style="color:#BABED8;">(One</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">XiaoMing</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">18</span><span style="color:#89DDFF;">&quot;</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">newObj:</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> obj)</span><span style="color:#89DDFF;">;</span></span></code></pre></div><h3 id="this" tabindex="-1">this <a class="header-anchor" href="#this" aria-label="Permalink to &quot;this&quot;">​</a></h3><p>this 并不是一个好的设计，它会随着作用域不同而变化。</p><p>this代表函数调用相关联的对象，通常叫做函数上下文</p><p>1、函数调用模式</p><p>在全局作用域或函数外部使用this，它指向全局对象。非严格模式下指向全局对象（在浏览器中，全局对象是window，在 nodejs 中，全局对象是 global），严格模式下是undefined</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">this</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">;</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// window</span></span></code></pre></div><p>2、方法调用时</p><p>在函数内部使用this，它的值取决于函数如何被调用。如果函数是作为一个方法被调用的，那么this就指向调用该方法的对象</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#BABED8;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">John</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#82AAFF;">sayHello</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">()</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Hello, </span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">this.</span><span style="color:#BABED8;">name</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BABED8;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">sayHello</span><span style="color:#BABED8;">()</span><span style="color:#89DDFF;">;</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// Hello, John</span></span></code></pre></div><p>在这个例子中，sayHello方法内的this指向obj对象。</p><p>3、构造器调用模式</p><p>在构造函数中使用this，它指向新创建的对象实例。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">Person</span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">name</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">this.</span><span style="color:#BABED8;">name</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">name</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#BABED8;"> john </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">new</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">Person</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">John</span><span style="color:#89DDFF;">&#39;</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(john</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">name)</span><span style="color:#89DDFF;">;</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// John</span></span></code></pre></div><p>在这个例子中，Person构造函数中的this指向新创建的对象john。</p><p>4、apply/call/bind 调用模式</p><p>当函数使用call、apply或bind方法被调用时，this指向传递给这些方法的第一个参数</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">sayHello</span><span style="color:#89DDFF;">()</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Hello, </span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">this.</span><span style="color:#BABED8;">name</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#BABED8;"> john </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span><span style="color:#BABED8;"> </span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">John</span><span style="color:#89DDFF;">&#39;</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#BABED8;"> jane </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span><span style="color:#BABED8;"> </span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Jane</span><span style="color:#89DDFF;">&#39;</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BABED8;">sayHello</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">call</span><span style="color:#BABED8;">(john)</span><span style="color:#89DDFF;">;</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// Hello, John</span></span>
<span class="line"><span style="color:#BABED8;">sayHello</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">call</span><span style="color:#BABED8;">(jane)</span><span style="color:#89DDFF;">;</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// Hello, Jane</span></span></code></pre></div><p>在这个例子中，sayHello函数中的this分别指向john和jane对象。</p><p>5、箭头函数中</p><p>箭头函数中使用this，指向定义函数时的父级作用域的 this，且无法被改变</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#BABED8;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">John</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#82AAFF;">sayHello</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">()</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">setTimeout</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Hello, </span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">this.</span><span style="color:#BABED8;">name</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">},</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1000</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BABED8;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">sayHello</span><span style="color:#BABED8;">()</span><span style="color:#89DDFF;">;</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// Hello, John</span></span></code></pre></div><p>优先级：</p><p>构造器调用 &gt; apply/call/bind &gt; 方法调用 &gt; 函数调用</p><h3 id="作用域、作用域链" tabindex="-1">作用域、作用域链 <a class="header-anchor" href="#作用域、作用域链" aria-label="Permalink to &quot;作用域、作用域链&quot;">​</a></h3><p>作用域是可访问变量的集合，它定义了变量、对象、函数的可访问性。根据可访问性，作用域可分为：</p><ul><li>全局作用域：代码中任何地方都能访问到的变量、函数、对象等，如：最外层变量和函数，未使用var声明的变量，window对象上的属性和函数</li><li>函数作用域：函数调用时创建的一个作用域，声明在函数内部的变量、函数、对象等只在函数体内可以访问到，包括函数的形参</li><li>块级作用域：ES6 引入的新概念，let 和 const 声明的变量具有块级作用域。块级作用域是指在 <code>{} </code>中声明的变量只能在这对花括号中被访问，不能在花括号外部被访问。</li></ul><p>变量的作用域指的是该变量的可访问区域，一个变量只能在其所处的作用域内被访问，在作用域外是不可见的。</p><p>作用域是一个存放变量的独立空间，它们之间可以相互嵌套，形成引用关系，这条链叫做作用域链。</p><p>作用域链 是 JavaScript 解析和查找变量的机制。当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。</p><p>作用域链的前端，是当前执行的代码所在环境的变量对象。作用域链的下一个变量对象来自外部环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。</p><p>标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误）。</p><h3 id="闭包" tabindex="-1">闭包 <a class="header-anchor" href="#闭包" aria-label="Permalink to &quot;闭包&quot;">​</a></h3><p><strong>核心</strong></p><p>让变量驻留在内存，不被回收。正常的函数在执行完后，内部的局部变量就被释放了，而当函数内部的局部变量一直被引用时，不会被回收。</p><p><strong>形成闭包的关键点</strong></p><p>1、函数嵌套函数：外层函数与内层函数形成嵌套，同时把内部函数 return 出去</p><p>2、内部函数引用外部函数的变量</p><p>3、返回内部函数：外部函数返回内部函数，使得内部函数可以在外部函数之外被执行。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">outerFunction</span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">outerVariable</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">function</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">innerFunction</span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">innerVariable</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">outerVariable:</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">outerVariable</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">innerVariable:</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">innerVariable</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> newFunction </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">outerFunction</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">outside</span><span style="color:#89DDFF;">&#39;</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#82AAFF;">newFunction</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">inside</span><span style="color:#89DDFF;">&#39;</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">;</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// Logs: outerVariable: outside, innerVariable: inside</span></span></code></pre></div><p><strong>应用场景</strong></p><p>1、数据封装和私有变量：闭包可以用来模拟私有变量，因为闭包内的变量只能通过闭包函数来访问。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">createCounter</span><span style="color:#89DDFF;">()</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">count</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">increment</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#BABED8;">count</span><span style="color:#89DDFF;">++;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">getCount</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">count</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> counter </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">createCounter</span><span style="color:#BABED8;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#BABED8;">counter</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">increment</span><span style="color:#BABED8;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(counter</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getCount</span><span style="color:#BABED8;">())</span><span style="color:#89DDFF;">;</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// 输出：1</span></span></code></pre></div><p>2、函数工厂：可以使用闭包创建可以记住状态的函数。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">createAdder</span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">x</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">y</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">x</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">y</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> add5 </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">createAdder</span><span style="color:#BABED8;">(</span><span style="color:#F78C6C;">5</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(</span><span style="color:#82AAFF;">add5</span><span style="color:#BABED8;">(</span><span style="color:#F78C6C;">2</span><span style="color:#BABED8;">))</span><span style="color:#89DDFF;">;</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// 输出：7</span></span></code></pre></div><p>比如：使用闭包设计单例模式</p><p>3、模块模式：使用闭包可以创建公有和私有方法和变量。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> myModule </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> (</span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">()</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">privateVar</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">publicAPI</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">increment</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#BABED8;">privateVar</span><span style="color:#89DDFF;">++;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">getPrivateVar</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">privateVar</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">publicAPI</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#BABED8;">)()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BABED8;">myModule</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">increment</span><span style="color:#BABED8;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(myModule</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getPrivateVar</span><span style="color:#BABED8;">())</span><span style="color:#89DDFF;">;</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// 输出：1</span></span></code></pre></div><p>4、在异步编程中维持状态：闭包可以在异步操作中保持变量的状态。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#BABED8;"> (</span><span style="color:#C792EA;">var</span><span style="color:#BABED8;"> i </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span><span style="color:#BABED8;"> i </span><span style="color:#89DDFF;">&lt;</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">5</span><span style="color:#89DDFF;">;</span><span style="color:#BABED8;"> i</span><span style="color:#89DDFF;">++</span><span style="color:#BABED8;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  (</span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">i</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">setTimeout</span><span style="color:#F07178;">(</span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">i</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 输出：0, 1, 2, 3, 4</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">},</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">i</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">*</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1000</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)(</span><span style="color:#BABED8;">i</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p><strong>注意点</strong></p><p>虽然闭包很有用，但是过度使用闭包可能会导致内存泄漏，因为闭包会阻止垃圾回收器清理那些不再被使用的变量</p><h3 id="js中实现继承的方式" tabindex="-1">js中实现继承的方式 <a class="header-anchor" href="#js中实现继承的方式" aria-label="Permalink to &quot;js中实现继承的方式&quot;">​</a></h3><ul><li>单独使用原型链： <ul><li>思路：把实例的原型指向另一个对象，在实例和原型之间形成一条链。</li><li>问题：（1）不同实例间的引用类型属性会共享；（2）子类型在实例化时不能给父类型的构造函数传参</li></ul></li><li>借用构造函数： <ul><li>思路：通过<code>call</code>或<code>apply</code>方法，在子类构造函数中调用父类构造函数，解决不能给父类型传参的问题；</li><li>问题：构造函数中的方法定义不能重用，也不能访问父类原型上定义的方法。</li></ul></li><li>组合继承（常用）： <ul><li>思路：使用原型链继承原型上的属性和方法，通过盗用构造函数继承实例属性</li><li>问题：效率不高，父类构造函数始终会被调用2次，一次在创建子类原型时调用，一次在子类构造函数中调用</li></ul></li><li>原型式继承：<code>Object.create()</code><ul><li>思路：创建一个临时构造函数，将传入的对象副本（浅复制）赋值给这个构造函数的原型，然后用这个临时类型创建实例。</li><li>问题：属性中包含的引用值始终会在相关对象间共享</li></ul></li><li>寄生式继承： <ul><li>思路：创建一个实现继承的函数，以某种方式增强这个函数的实例对象，然后返回这个对象</li><li>问题：给对象添加函数会导致函数难以重用，与构造函数模式类似</li></ul></li><li>寄生式组合继承：（最佳） <ul><li>思路：以寄生式的方式取得父类原型的副本，然后将子类的构造函数设置为这个副本</li></ul></li></ul><h3 id="js-中对象创建的方式" tabindex="-1">js 中对象创建的方式 <a class="header-anchor" href="#js-中对象创建的方式" aria-label="Permalink to &quot;js 中对象创建的方式&quot;">​</a></h3><p><strong>字面量的形式直接创建对象</strong>，创建大量相似对象时，会产生大量的重复代码</p><ol><li>工厂模式：用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。缺点：它只是简单的封装了复用代码，无法和某个类型联系起来，没有建立对象和类型间的关系。</li><li>构造函数模式：即通过 <code>new Function()</code>的方式创建，新建的对象与原型通过 prototype 建立了联系。缺点：造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，每次都会新建一个函数对象，浪费内存，国灰函数是所有的实例都可以通用的。</li><li>原型模式：每个函数都有一个 prototype 属性，用来指向原型对象，因此可以使用原型对象来添加公共属性和方法，实现代码复用。缺点：不能通过传入参数来初始化值；如果存在引用类型的值，那么所有实例将共享一个对象。</li><li>组合构造函数模式+原型模式：创建自定义类型最常见的方式，通过构造函数初始化对象的属性，通过原型对象实现函数方法的复用。缺点：由于使用了两种不同的模式，代码的封装性不够好。</li><li>动态原型模式：将原型方法赋值的创建过程移动到构造函数内部，通过判断属性是否存在，可以实现仅在第一次调用函数时对原型对象赋值一次的效果，这种方式很好的对上面的混合模式进行了封装</li><li>寄生构造函数模式：与工厂模式基本相同，主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展，这样既不用修改原来的构造函数，也扩展了对象。</li></ol><h3 id="异步编程的实现" tabindex="-1">异步编程的实现 <a class="header-anchor" href="#异步编程的实现" aria-label="Permalink to &quot;异步编程的实现&quot;">​</a></h3><p>js 中的异步机制有以下几种：</p><p>1、<strong>回调函数</strong></p><p>缺点是多个回调函数嵌套时会造成回调地狱，回调函数间耦合度高，不利于维护</p><p>2、<strong>Promise 方式</strong></p><p>将嵌套的回调函数使用 then 方法作为链式调用，但是可能造成代码语义不明确</p><p>3、<strong>generator 方式</strong></p><p>通过转移函数的执行权实现，当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再转移回来。此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如 说 co 模块等方式来实现 generator 的自动执行。</p><p>4、<strong>async 函数方式</strong></p><p>async 是 generator 和 promise 实现的一个自动执行的语法糖，内部自带执行器，当函数内部执行到 await 语句时，如果语句返回一个 promise 对象，则函数会等待它的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑转化为同步的顺序来书写，并且这个函数可以自动执行。</p><h3 id="apply、call、bind" tabindex="-1">apply、call、bind <a class="header-anchor" href="#apply、call、bind" aria-label="Permalink to &quot;apply、call、bind&quot;">​</a></h3><p>作用相同，都可以改变函数的 this 上下文</p><ul><li>apply：接受2 个参数，一个是函数运行的作用域（也就是 this 指向的值），另一个是一个参数数组/类数组</li><li>call： 与 apply 相似，但是它接受的是一个参数列表，而不是一个参数数组，也就是说接收参数数量不固定</li><li>bind：与 apply 和 call 不同，bind 是创建一个新的函数，而不会立即执行，它的参数就是 this 指向</li></ul><h3 id="深拷贝与浅拷贝" tabindex="-1">深拷贝与浅拷贝 <a class="header-anchor" href="#深拷贝与浅拷贝" aria-label="Permalink to &quot;深拷贝与浅拷贝&quot;">​</a></h3><p>深拷贝和浅拷贝是两种常见的复制对象的方法，它们之间的主要区别在于如何处理对象的属性值</p><p>浅拷贝（Shallow Copy）：创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</p><p>深拷贝（Deep Copy）：创建一个新对象，复制原始对象的属性值，如果属性值是引用类型，会递归复制其内部的属性，直到所有引用类型的属性都被复制为基本类型的属性。所以，修改一个对象的属性不会影响到被复制的对象。</p><p>深拷贝实现方式：</p><p>1、<code>JSON.parse(JSON.stringify(obj))</code></p><p>序列化和反序列化，最简单的深拷贝方法，但它有一些限制：</p><ul><li>取不到值为 undefined 的 key</li><li>不能复制函数和循环引用的对象</li><li>Date 对象会被转变为 date 字符串</li><li>不能拷贝对象原型链上的属性和方法</li></ul><p>2、递归</p><p>可以复制任何类型的对象，但需要注意防止循环引用导致的无限递归</p><p>参见<a href="./hand-written">手写深拷贝</a></p><p>3、第三方库</p><p>如：lodash 的 _.cloneDeep 方法</p><p>4、扩展运算符或Object.assign</p><p>只能对第一层属性进行拷贝，如果属性值是对象，那么这个属性的拷贝仍然是浅拷贝</p><h3 id="esmodule和commonjs异同" tabindex="-1">ESModule和CommonJs异同 <a class="header-anchor" href="#esmodule和commonjs异同" aria-label="Permalink to &quot;ESModule和CommonJs异同&quot;">​</a></h3><ul><li>CommonJS的require是同步的，只适合用在服务端；ESM也可以用在服务端，但还需要遵循一些特殊的规则；</li><li>ESM支持加载CommonJS模块，但CommonJS不能加载ESM模块</li><li>CommonJS是对模块的浅拷贝（就是模块内部的变化，会反映到模块外），并且可以对它重新赋值；ESM是对模块的引用，且是只读的，不能改变其值，类似const，还存在提升</li><li>CommonJS是运行时加载，ESM是编译时输出接口，可以对模块进行静态分析</li><li>CommonJS遇到循环依赖时，只输出已经执行的部分，后续的输出或变化不影响已输出的变量；而ESM加载时变量不会被缓存，真正取值的时候就能取到最终值</li><li>CommonJS的this指向当前模块；ESM的this指向undefined</li></ul><h2 id="es6" tabindex="-1">ES6+ <a class="header-anchor" href="#es6" aria-label="Permalink to &quot;ES6+&quot;">​</a></h2><h3 id="let、const、var的区别" tabindex="-1">let、const、var的区别 <a class="header-anchor" href="#let、const、var的区别" aria-label="Permalink to &quot;let、const、var的区别&quot;">​</a></h3><ul><li>let、const具有块级作用域，var没有</li><li>var声明的变量可以重复声明，const、let不允许</li><li>暂时性死区：由于const、let不存在变量提升，所以在声明前使用变量会报错，形成暂时性死区。var可以提升变量，所以没有。</li><li>初始值设置：var、let可以没有初值，const必须设置初始值</li><li>指针指向：let创建的变量可以更改指针指向，即重新赋值。const不允许，它保证指针的指向的内存地址不变，对于基本类型值就在内存地址，对引用类型变量指向内存地址，只要地址不变，就代表值没变</li></ul><h3 id="proxy" tabindex="-1">Proxy <a class="header-anchor" href="#proxy" aria-label="Permalink to &quot;Proxy&quot;">​</a></h3><p>是 JavaScript 的内置对象，用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。</p><p>创建一个 Proxy 对象需要两个参数：目标对象（target）和处理程序对象（handler）。处理程序对象是一个包含一组方法的对象，这些方法用于拦截目标对象的操作。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#BABED8;"> target </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{};</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#BABED8;"> handler </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#82AAFF;">get</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">target</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">prop</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">receiver</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">\`</span><span style="color:#C3E88D;">Getting </span><span style="color:#89DDFF;">\${</span><span style="color:#BABED8;">prop</span><span style="color:#89DDFF;">}\`</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">Reflect</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">target</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">prop</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">receiver</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#82AAFF;">set</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">target</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">prop</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">value</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">receiver</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">\`</span><span style="color:#C3E88D;">Setting </span><span style="color:#89DDFF;">\${</span><span style="color:#BABED8;">prop</span><span style="color:#89DDFF;">}</span><span style="color:#C3E88D;"> to </span><span style="color:#89DDFF;">\${</span><span style="color:#BABED8;">value</span><span style="color:#89DDFF;">}\`</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">Reflect</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">set</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">target</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">prop</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">value</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">receiver</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#BABED8;"> proxy </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">new</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">Proxy</span><span style="color:#BABED8;">(target</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> handler)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BABED8;">proxy</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">name </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">GitHub Copilot</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span><span style="color:#BABED8;">  </span><span style="color:#676E95;font-style:italic;">// 输出 &quot;Setting name to GitHub Copilot&quot;</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(proxy</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">name)</span><span style="color:#89DDFF;">;</span><span style="color:#BABED8;">  </span><span style="color:#676E95;font-style:italic;">// 输出 &quot;Getting name&quot; 和 &quot;GitHub Copilot&quot;</span></span></code></pre></div><p>Proxy 提供了很多其他的拦截操作，包括 apply（拦截函数调用）、has（拦截 in 操作符）、deleteProperty（拦截 delete 操作符）、ownKeys（拦截 Object.getOwnPropertyNames 方法）等。</p><h3 id="箭头函数" tabindex="-1">箭头函数 <a class="header-anchor" href="#箭头函数" aria-label="Permalink to &quot;箭头函数&quot;">​</a></h3><p>箭头函数是 ES6 中引入的一种新的函数语法。语法更简洁，没有自己的this、arguments、super、new.target。更适用于本为需要匿名函数的地方，并且它不能做构造函数。</p><p>箭头函数的特性：</p><ul><li>书写简洁：一个参数时可省略小括号，函数体只有一个返回语句时可省略大括号</li><li>没有自己的this：它只从自己作用域的上一层继承this，所以在定义时已经确定了this指向，不会改变</li><li>不能作为构造函数：没有prototype</li><li>没有arguments 对象：可以使用rest参数来访问参数列表</li><li>不能用作Generator函数，不能使用yeild关键字</li></ul><h3 id="arguments" tabindex="-1">arguments <a class="header-anchor" href="#arguments" aria-label="Permalink to &quot;arguments&quot;">​</a></h3><p>一个类数组对象，代表了传递给一个函数的参数列表，在函数内部，可以使用 arguments 对象来访问所有传递给该函数的参数，包括那些没有对应形参的实参。</p><p>它不能显示的创建，只有函数中可用。</p><p>作用：可以不用给函数设定形参，而动态的通过arguments为函数加入参数。</p><h3 id="class-类" tabindex="-1">class 类 <a class="header-anchor" href="#class-类" aria-label="Permalink to &quot;class 类&quot;">​</a></h3><p>ES6 引入了 class 关键字来实现面向对象编程的类。类是一种特殊的函数，可以用来创建对象。类的语法提供了一种更清晰、更简单的方式来创建对象和处理继承。</p><p>类（class）的本质就是函数，可以通过 typeof 操作符验证</p><h3 id="尾调用优化" tabindex="-1">尾调用优化 <a class="header-anchor" href="#尾调用优化" aria-label="Permalink to &quot;尾调用优化&quot;">​</a></h3><p>尾调用优化（Tail Call Optimization，TCO）是一种在某些编程语言中用于提高递归函数性能的技术。在 js 中，尾调用优化是 ES6 标准的一部分。</p><p>尾调用是指<strong>函数的最后一步是调用另一个函数</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">foo</span><span style="color:#89DDFF;">()</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">bar</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;">  </span><span style="color:#676E95;font-style:italic;">// 这是一个尾调用</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>函数调用会在内存形成一个&quot;调用记录&quot;，又称&quot;调用帧&quot;（call frame），保存调用位置和内部变量等信息。</p><p>如果在函数A的内部调用函数B，那么在A的调用记录上方，还会形成一个B的调用记录。等到B运行结束，将结果返回到A，B的调用记录才会消失。如果函数B内部还调用函数C，那就还有一个C的调用记录栈，以此类推。所有的调用记录，就形成一个<a href="https://zh.wikipedia.org/wiki/%E8%B0%83%E7%94%A8%E6%A0%88" target="_blank" rel="noreferrer">&quot;调用栈&quot;</a>（call stack）。</p><p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。</p><p>使用尾调用的话，因为已经是函数的最后一步，所以这时可以不再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。</p><p><strong>注意</strong>：虽然 ES6 标准规定了尾调用优化，但并非所有的 JavaScript 引擎都实现了这个特性</p><h3 id="promise" tabindex="-1">Promise <a class="header-anchor" href="#promise" aria-label="Permalink to &quot;Promise&quot;">​</a></h3><p>异步编程的一种解决方案，解决了回调地狱的问题</p><p>它是一个对象，也可以理解为一个容器，它可以获取异步操作的消息。</p><p>Promise 的实例有 3 个状态：Pending 进行中，Resolved 已完成，Rejected 已拒绝，它的状态只能从 pending-&gt;fulfilled:Resolved或 pending-&gt;rejected:Rejected。</p><p>优点：</p><p>有了 Promise 对象（对象可以保存状态，函数不可以，除了闭包），可以将异步操作以同步的流程表达出来，避免了回调地狱。提供了统一的接口，使得控制异步操作更加容易。</p><p>缺点：</p><p>无法取消 Promise，一旦创建就会立即执行；如果不设置回调函数，Promise 内部的错误不会反应到外部；当处理pending 状态时，无法得知具体进展到哪一步（刚开始还是即将完成）</p><p><strong>原型方法</strong></p><p>then()、catch()、finally()</p><p><strong>常用方法</strong></p><p>Promise.all：同时执行多个 promise 实例，包装成一个新的 Promise 实例。有任何一个失败则该 Promise 失败，返回第一个失败的子 Promise 的结果。</p><p>Promise.race：任意一个promise被拒绝或者成功，则会采用第一个promise作为他的返回值。</p><p>Promise.any：任意一个完成时就会终止，会忽略所有被拒绝掉的promise，直到第一个promise完成</p><p>Promise.allSettled：所有promise被拒绝后会返回一个拒绝的promise数组</p><h3 id="async-await" tabindex="-1">async/await <a class="header-anchor" href="#async-await" aria-label="Permalink to &quot;async/await&quot;">​</a></h3><p>async/await也是异步编程的解决方案，是基于generator函数对promise封装的语法糖，它内置执行器，不需要额外的调用直接会自动执行并输出结果。</p><p>async 函数返回的是一个 Promise对象，如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve()封装成 Promise 对象。</p><p>对比 Promise 的优势：</p><ul><li>避免 then的链式调用带来的可读性问题</li><li>Promise 传递中间值不方便，而 async/await 是同步写法，传递中间值非常优雅</li><li>错误处理友好，可以使用 try/catch</li><li>调试友好</li></ul><p>适用场景：</p><p>处理多个 Promise 组成的then 链。比如多个步骤，每个步骤都是异步，且依赖于上一个步骤的结果。</p><h2 id="js-内存管理" tabindex="-1">js 内存管理 <a class="header-anchor" href="#js-内存管理" aria-label="Permalink to &quot;js 内存管理&quot;">​</a></h2><h3 id="堆和栈" tabindex="-1">堆和栈 <a class="header-anchor" href="#堆和栈" aria-label="Permalink to &quot;堆和栈&quot;">​</a></h3><p>堆和栈的概念存在于数据结构和操作系统中，js中常说的是针对操作系统。</p><p>在数据结构中：</p><ul><li>栈中数据先进后出（像个有底的桶）</li><li>堆是一个优先队列，按优先级来排序，可以按大小来规定</li></ul><p>在操作系统中，内存分为栈区和堆区：</p><ul><li>栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈</li><li>堆区内存一般由开发者分配释放，若不释放，则由垃圾回收机制回收</li></ul><h3 id="js-内存管理-1" tabindex="-1">js 内存管理 <a class="header-anchor" href="#js-内存管理-1" aria-label="Permalink to &quot;js 内存管理&quot;">​</a></h3><p><strong>生命周期/主要步骤</strong></p><p>1、分配内存：由 js 引擎自动分配</p><p>2、使用内存：当使用变量时，实际正在使用分配给该变量的内存</p><p>3、释放内存：当数据不再需要进，js 引擎会自动释放其内存，这个过程称为垃圾回收</p><p><strong>内存限制</strong></p><p>64 位系统约 1.4GB，32 位约为 0.7GB</p><p><strong>内存分配</strong></p><p>栈：存放基本数据类型（静态数据）直接在栈空间内分配，引擎知道数据的大小，所以会分配固定数量的内存；包括：string、number、boolean、undefined、null、指向对象和函数的引用</p><p>堆：引用数据类型（动态数据）在堆内存中开辟空间，并将该空间的指针存储在栈中，变量指向的是堆内存的地址。</p><p>池：一般也归类栈中，一般存放常量，也叫常量池。</p><p>特殊的：闭包中的变量是在堆内存中的。</p><p>字符串常量池：字符串存在字符串常量池中，被栈或堆上的变量引用。如果变量的值是字符串字面量，则在栈上的变量直接引用字符串常量池中的字符串；如果是字符串是 new String 创建的，则会在堆上创建 String 对象，指向字符串常量池中的字符串，栈上变量指向堆中的 String 对象。</p><h3 id="js垃圾回收-gc" tabindex="-1">js垃圾回收/GC <a class="header-anchor" href="#js垃圾回收-gc" aria-label="Permalink to &quot;js垃圾回收/GC&quot;">​</a></h3><p>主要依赖于可达性的概念，简单来说，如果一个值无法通过根（全局对象）直接或间接访问，那么这个值就被认为是不可达的，因此可以被回收。</p><ul><li>引用计数（Reference Counting）：早期使用的垃圾回收算法，现在已经很少使用。基本思想是跟踪每个值的引用数。当声明一个变量并将一个引用类型值赋给该变量时，这个值的引用数就会加1。当引用被删除时，引用数就会减1。当引用数变为0时，说明该值不再需要，因此可以被回收。但是，引用计数算法有一个问题，那就是无法处理循环引用。</li><li>标记-清除（Mark-and-Sweep）：这是最常用的垃圾回收算法。它分为两个阶段：标记阶段和清除阶段。在标记阶段，垃圾回收器会遍历所有的对象，标记活动对象（即仍在使用的对象）和非活动对象（即可以被删除的对象）。在清除阶段，垃圾回收器会删除所有被标记为非活动的对象，并回收它们的内存。</li></ul><h3 id="v8-的-gc" tabindex="-1">v8 的 GC <a class="header-anchor" href="#v8-的-gc" aria-label="Permalink to &quot;v8 的 GC&quot;">​</a></h3><p>主要通过两种算法：标记-清除（Mark-Sweep）和分代收集（Generational Collection）</p><ul><li>标记-清除（Mark-Sweep）：这是 V8 引擎的主要垃圾回收算法。在标记阶段，垃圾回收器会遍历所有的对象，标记活动对象（即仍在使用的对象）和非活动对象（即可以被删除的对象）。在清除阶段，垃圾回收器会删除所有被标记为非活动的对象，并回收它们的内存。这个过程会导致内存碎片化，因此 V8 还会进行内存整理，将活动对象移动到一起。</li><li>分代收集（Generational Collection）：V8 引擎将内存分为新生代（Young Generation）和老生代（Old Generation）两部分。新生代中的对象是生命周期短的对象，老生代中的对象是生命周期长的对象。新生代使用 Scavenge 算法进行垃圾回收，老生代使用 Mark-Sweep 和 Mark-Compact 算法进行垃圾回收 <ul><li>Scavenge 算法：Scavenge 算法将新生代内存空间分为两部分，一部分只用来分配新对象，另一部分空闲。当进行垃圾回收时，会检查这部分内存中的活动对象，然后将这些活动对象复制到另一部分空闲内存中，并清除原来内存中的所有对象。然后交换这两部分内存的角色，重复这个过程</li><li>Mark-Compact 算法：Mark-Compact 是一种用于老生代的垃圾回收算法。它首先标记所有活动对象，然后将所有活动对象向一端移动，然后直接清除端边界以外的内存。</li></ul></li></ul><h3 id="内存泄漏" tabindex="-1">内存泄漏 <a class="header-anchor" href="#内存泄漏" aria-label="Permalink to &quot;内存泄漏&quot;">​</a></h3><p>由于不正确的内存管理，导致程序无法释放已经不再使用的内存。这可能会导致应用程序的内存使用量逐渐增加，从而影响应用程序的性能，甚至导致应用程序崩溃。</p><p>1、不必要的全局变量：因为全局变量在整个应用程序的生命周期内都不会被回收</p><p>2、未清除的定时器：如果定时器的回调函数引用了外部变量，那么这些变量在定时器存在期间都不会被回收</p><p>3、不正确的闭包：如果闭包引用了外部函数的变量，那么这些变量在闭包存在期间都不会被回收</p><p>4、脱离 DOM 的引用：如果保留了对已删除 DOM 元素的引用，那么这些 DOM 元素的内存就不会被回收</p><h2 id="其他" tabindex="-1">其他 <a class="header-anchor" href="#其他" aria-label="Permalink to &quot;其他&quot;">​</a></h2><h4 id="for-in-和-for-of" tabindex="-1">for...in 和 for...of <a class="header-anchor" href="#for-in-和-for-of" aria-label="Permalink to &quot;for...in 和 for...of&quot;">​</a></h4><p>for...of：</p><ul><li>es6 新增，允许遍历实现了 Iterator 接口的数据结构，如 Map、Set、数组、对象、类数组对象、字符串、Generator 对象</li><li>遍历时获取的是对象的键值</li><li>只遍历当前对象</li><li>对数组遍历只返回数组的下标对应的属性值</li></ul><p>for...in：</p><ul><li>es3 中的方法，获取对象的键名</li><li>会遍历对象的整个原型链，性能差</li><li>对数组遍历会返回所有可枚举属性，包含原型链上的</li></ul><h3 id="object-assign和扩展运算符" tabindex="-1">Object.assign和扩展运算符 <a class="header-anchor" href="#object-assign和扩展运算符" aria-label="Permalink to &quot;Object.assign和扩展运算符&quot;">​</a></h3><p>两者都是浅拷贝，</p><ul><li>Object.assign会把源对象的可枚举属性复制到目标对象中，如果重名会覆盖；</li><li>扩展运算符把数组或对象中的每个值拷贝到一个新的数组或对象，不复制继承的属性，但会复制Symbol属性</li></ul><h3 id="fetch" tabindex="-1">fetch <a class="header-anchor" href="#fetch" aria-label="Permalink to &quot;fetch&quot;">​</a></h3><p>es6 中出现的原生 js 语法，ajax 的替代品，基于 Promise 对象封装，代码结构简单。</p><p>优点：</p><ul><li>语法简洁，更加语义化</li><li>基于 Promise 实现，支持 async/await</li><li>更加底层，提供了丰富的 api，如 request、response</li></ul><p>缺点：</p><ul><li>只对网络请求报错，对 400、500都当作成功的请求</li><li>默认不带 cookie，需要添加配置项：<code>fetch(url,{credentials:&#39;include&#39;})</code></li><li>不支持 abort，不支持超时控制</li><li>不能原生监测请求的进度，xhr 可以</li></ul>`,209),e=[o];function t(c,r,y,F,D,i){return a(),n("div",null,e)}const E=s(p,[["render",t]]);export{A as __pageData,E as default};
