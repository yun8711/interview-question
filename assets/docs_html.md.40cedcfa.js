import{_ as a,S as t,N as e,Q as l}from"./chunks/framework.d2ce16e8.js";const i="/interview-question/assets/image-20230625201447760.4171ae6a.png",f=JSON.parse('{"title":"HTML","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"docs/html.md","filePath":"docs/html.md","lastUpdated":1708601980000}'),r={name:"docs/html.md"},p=l('<h1 id="html" tabindex="-1">HTML <a class="header-anchor" href="#html" aria-label="Permalink to &quot;HTML&quot;">​</a></h1><h3 id="语义化" tabindex="-1">语义化 <a class="header-anchor" href="#语义化" aria-label="Permalink to &quot;语义化&quot;">​</a></h3><p>语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）。通俗来讲，就是用正确的标签做正确的事情，来更清晰的表达文档结构。</p><p><strong>优点：</strong></p><ul><li>对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，有利于 SEO，搜索引擎根据标签来确定上下文和关键字的权重。</li><li>语义类还支持读屏软件，根据文章可以自动生成目录。</li><li>易于用户阅读，样式丢失时仍能让页面显现清晰的结构</li><li>方便屏幕阅读器解析，有利于无障碍阅读</li><li>具有可读性，有利于开发和维护</li></ul><h3 id="doctype-文档类型-的作用" tabindex="-1">DOCTYPE（文档类型）的作用 <a class="header-anchor" href="#doctype-文档类型-的作用" aria-label="Permalink to &quot;DOCTYPE（文档类型）的作用&quot;">​</a></h3><p>DOCTYPE 是 HTML5 中一种标准通用标记语言的文档类型声明，它的目的是告诉浏览器（解析器）应该以什么样（html 或 xhtml）的文档类型定义来解析文档，不同的渲染模式会影响浏览器对 CSS 代码甚⾄ JavaScript 脚本的解析。它必须声明在 HTML⽂档的第⼀⾏。</p><p>浏览器渲染页面的两种模式（可通过 document.compatMode 获取，比如，语雀官网的文档类型是 CSS1Compat）：</p><p>CSS1Compat：标准模式（Strick mode），默认模式，浏览器使用 W3C 的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。</p><p>BackCompat：怪异模式（混杂模式）(Quick mode)，浏览器使用自己的怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。</p><h3 id="浏览器是如何对-html5-的离线储存资源进行管理和加载" tabindex="-1">浏览器是如何对 html5 的离线储存资源进行管理和加载？ <a class="header-anchor" href="#浏览器是如何对-html5-的离线储存资源进行管理和加载" aria-label="Permalink to &quot;浏览器是如何对 html5 的离线储存资源进行管理和加载？&quot;">​</a></h3><p>在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问页面 ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过页面并且资源已经进行离线存储了，那么浏览器就会使用离线 的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，就会重新下载文件中的资源并进行离线存储。</p><p>离线的情况下，浏览器会直接使用离线存储的资源。</p><h3 id="script-标签中-defer-和-async-的区别" tabindex="-1">script 标签中 defer 和 async 的区别 <a class="header-anchor" href="#script-标签中-defer-和-async-的区别" aria-label="Permalink to &quot;script 标签中 defer 和 async 的区别&quot;">​</a></h3><p>如果没有defer或async属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样 就阻塞了后续文档的加载。</p><p>下图可以直观的看出三者之间的区别：</p><p><img src="'+i+'" alt="image-20230625201447760"></p><p>蓝色代表 js 脚本网络加载时间，红色代表 js 脚本执行时间，绿色代表 html 解析。</p><p>defer 和 async 属性都是去异步加载外部的 JS 脚本文件，它们都不会阻塞页面的解析，其区别如下：</p><ul><li>执行顺序：多个带 async 属性的标签，不能保证加载的顺序；多个带 defer 属性的标签，按照加载顺序执行；</li><li>脚本是否并行执行：async 属性，表示后续文档的加载和执行与 js 脚本的加载和执行是并行进行的，即异步执行；defer 属性，加载后续文档的过程和 js 脚本的加载（此时仅加载不执行）是并行进行的（异步），js 脚本需要等到文档所有元素解析完成之后才执行， DOMContentLoaded 事件触发执行之前。</li></ul><h3 id="行内元素有哪些-块级元素有哪些-空-volid-元素有哪些" tabindex="-1">行内元素有哪些？块级元素有哪些？空（volid）元素有哪些？ <a class="header-anchor" href="#行内元素有哪些-块级元素有哪些-空-volid-元素有哪些" aria-label="Permalink to &quot;行内元素有哪些？块级元素有哪些？空（volid）元素有哪些？&quot;">​</a></h3><p>行内元素有：a b span img input select strong；</p><p>块级元素有：div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p；</p><p>空元素，即没有内容的 HTML 元素。空元素是在开始标签中关闭的，</p><p>也就是空元素没有闭合标签：</p><p>常见的有：<code>&lt;br&gt;、&lt;hr&gt;、&lt;img&gt;、&lt;input&gt;、&lt;link&gt;、&lt;meta&gt;</code></p><p>鲜见的有：<code>&lt;area&gt;、&lt;base&gt;、&lt;col&gt;、&lt;colgroup&gt;、&lt;command&gt;、&lt;embed&gt;、&lt;keygen&gt;、&lt;param&gt;、&lt;source&gt;、&lt;track&gt;、&lt;wbr&gt;</code></p><h3 id="canvas-和-svg-的区别" tabindex="-1">Canvas 和 SVG 的区别 <a class="header-anchor" href="#canvas-和-svg-的区别" aria-label="Permalink to &quot;Canvas 和 SVG 的区别&quot;">​</a></h3><p><strong>SVG</strong></p><p>可缩放矢量图形（Scalable Vector Graphics）是基于可扩展标记语言 XML 描述的 2D 图形的语言，SVG 基于 XML 就意味着 SVG DOM 中的每个元素都是可用的，可以为某个元素附加 Javascript 事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。</p><p>注：矢量图，也称为面向对象的图像或绘图图像，在数学上定义为一系列由线连接的点。矢量文件中的图形元素称为对象。每个对象都是一个自成一体的实体，它具有颜色、形状、轮廓、大小和屏幕位置等属性。</p><p>其特点如下：</p><ul><li>不依赖分辨率</li><li>支持事件处理器</li><li>最适合带有大型渲染区域的应用程序（比如谷歌地图）</li><li>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）</li><li>不适合游戏应用</li></ul><p><strong>Canvas</strong></p><p>Canvas 是画布，通过 Javascript 来绘制 2D 图形，是逐像素进行渲染的。其位置发生改变，就会重新进行绘制。</p><p>其特点如下：</p><ul><li>依赖分辨率</li><li>不支持事件处理器</li><li>弱的文本渲染能力</li><li>能够以 .png 或 .jpg 格式保存结果图像</li><li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li></ul><h3 id="drag-api" tabindex="-1">drag API <a class="header-anchor" href="#drag-api" aria-label="Permalink to &quot;drag API&quot;">​</a></h3><p>dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。</p><p>darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。</p><p>dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。</p><p>dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。</p><p>dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。</p><p>drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。</p><p>dragend：事件主体是被拖放元素，在整个拖放操作结束时触发。</p>',45),s=[p];function o(d,n,c,h,m,g){return t(),e("div",null,s)}const b=a(r,[["render",o]]);export{f as __pageData,b as default};
