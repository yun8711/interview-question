import{_ as e,S as a,N as o,Q as s}from"./chunks/framework.d2ce16e8.js";const F=JSON.parse('{"title":"Vue 生态","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"docs/vue-peripheral.md","filePath":"docs/vue-peripheral.md","lastUpdated":1708601980000}'),t={name:"docs/vue-peripheral.md"},r=s(`<h1 id="vue-生态" tabindex="-1">Vue 生态 <a class="header-anchor" href="#vue-生态" aria-label="Permalink to &quot;Vue 生态&quot;">​</a></h1><h2 id="vue-router" tabindex="-1">vue-router <a class="header-anchor" href="#vue-router" aria-label="Permalink to &quot;vue-router&quot;">​</a></h2><h3 id="路由导航解析流程" tabindex="-1">路由导航解析流程 <a class="header-anchor" href="#路由导航解析流程" aria-label="Permalink to &quot;路由导航解析流程&quot;">​</a></h3><ol><li>导航被触发。</li><li>在失活的组件里调用：beforeRouteLeave，可取消离开</li><li>调用全局前置守卫： beforeEach，可用于登录验证，全局loading等</li><li>在重用的组件里调用：beforeRouteUpdate</li><li>在路由配置里调用，路由独享守卫：beforeEnter</li><li>解析异步路由组件。</li><li>在被激活的组件里调用：beforeRouteEnter</li><li>调用全局解析守卫：beforeResolve</li><li>导航被确认</li><li>调用全局后置钩子：afterEach</li><li>触发dom更新，组件的生命周期：beforeCreate、created、beforeMount、deactivated、mounted、activated</li><li>调用beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入</li></ol><br><h3 id="vue-router两种模式实现原理" tabindex="-1">vue-router两种模式实现原理 <a class="header-anchor" href="#vue-router两种模式实现原理" aria-label="Permalink to &quot;vue-router两种模式实现原理&quot;">​</a></h3><p>都是利用浏览器自身的属性，基于h5的api，通过调用浏览器提供的接口来实现前端路由。</p><p>vue-router通过mixin全局混入在beforeCreate钩子中将router加入vue实例中，监听当前路由的变化来匹配不同的路由规则，加载对应的组件。</p><p>1、<strong>hash模式：</strong></p><p>原理：hash是指url中#及之后的字符串，当url中的hash值改变时，触发<code>onhashchange</code>事件，路由系统监听此事件来实现。</p><p>vue-router的默认模式，用url的hash来模拟完整的url，hash值不会被包含在请求中，只用来指导浏览器动态，不会向后端发送请求。只有hash改变才会被添加到浏览器记录栈。hash原本用来做页面定位，可以兼容到IE8。</p><p>2、<strong>history模式：</strong></p><p>原理：使用h5的<code>pushState()</code>和<code>replaceState()</code>方法，对浏览器记录栈进行修改，并监听<code>popState</code>事件（前进后退）来触发状态变更。</p><p>history模式下，前端url必须和实际向后端发起请求的url一致，否则会返回404，所以服务端需要配置一个缺省页面，比如index.html，当任何静态资源都不匹配时，返回这个页面。可以兼容到IE10。</p><br><h3 id="vue-router跳转和location-href的区别" tabindex="-1">vue-router跳转和location.href的区别 <a class="header-anchor" href="#vue-router跳转和location-href的区别" aria-label="Permalink to &quot;vue-router跳转和location.href的区别&quot;">​</a></h3><p><code>location.href</code>使用简单方便，但会刷新页面</p><p><code>history.pushState()</code>，静态跳转，不刷新页面</p><p><code>router.push()</code>：与<code>history.pushState()</code>行为相同，使用的diff算法，实现了按需加载，减少了dom消耗</p><br><h3 id="路由守卫" tabindex="-1">路由守卫 <a class="header-anchor" href="#路由守卫" aria-label="Permalink to &quot;路由守卫&quot;">​</a></h3><p>当需要通过路由来进行一些操作，比如登录权限验证、页面进度条、页面loading、控制页面滚动条。</p><p>植入方式：全局、单个路由独享、组件级</p><p>1、<strong>全局路由钩子</strong></p><p>beforeEach：全局前置守卫，进入路由之前</p><p>beforeResolve：全局解析守卫，在beforeRouteEnter之后调用</p><p>afterEach：全局后置钩子，进入路由之后</p><p>2、<strong>单个路由独享</strong></p><p>beforeEnter：为某个路由单独配置守卫，参数：to、from、next</p><p>3、<strong>组件内钩子</strong></p><p>beforeRouteEnter：进入组件前触发，这时不能访问this</p><p>beforeRouteUpdate：当前地址改变且组件被复用时触发，比如：带有动态参数的路径foo/1和foo/2之间跳转时</p><p>beforeRouteLeave：离开组件时被调用</p><br><h3 id="路由跳转方式" tabindex="-1">路由跳转方式 <a class="header-anchor" href="#路由跳转方式" aria-label="Permalink to &quot;路由跳转方式&quot;">​</a></h3><p>声明式，router-link标签</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">router-link</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">:to</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">{name:&#39;home&#39;}</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">router-link</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">router-link</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">:to</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">{path:&#39;/home&#39;}</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">router-link</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><p>编程式</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">this.</span><span style="color:#BABED8;">$router</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">push</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">/home</span><span style="color:#89DDFF;">&#39;</span><span style="color:#BABED8;">)</span></span>
<span class="line"><span style="color:#89DDFF;">this.</span><span style="color:#BABED8;">$router</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">push</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">{</span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">:</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">home</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">}</span><span style="color:#BABED8;">)</span></span>
<span class="line"><span style="color:#89DDFF;">this.</span><span style="color:#BABED8;">$router</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">push</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">{</span><span style="color:#F07178;">path</span><span style="color:#89DDFF;">:</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">/home</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">}</span><span style="color:#BABED8;">)</span></span></code></pre></div><br><h3 id="route和-router的区别" tabindex="-1">$route和$router的区别 <a class="header-anchor" href="#route和-router的区别" aria-label="Permalink to &quot;$route和$router的区别&quot;">​</a></h3><p>$route是<strong>路由信息对象</strong>，它包括path、params、hash、query、fullPath、matched、name等路由信息参数，</p><p>$router是<strong>路由实例对象</strong>，它包括了路由的跳转方法，钩子函数等</p><br><h3 id="params和query的区别" tabindex="-1">params和query的区别 <a class="header-anchor" href="#params和query的区别" aria-label="Permalink to &quot;params和query的区别&quot;">​</a></h3><p>query：要用path来引入，类似get请求传参，在地址栏中可以显示参数，刷新不会丢失参数</p><p>params：使用路由的name来引入，类似post请求传参，参数不在地址中显示，刷新会丢失参数</p><br><h3 id="路由懒加载" tabindex="-1">路由懒加载 <a class="header-anchor" href="#路由懒加载" aria-label="Permalink to &quot;路由懒加载&quot;">​</a></h3><ol><li>vue-router官方写法，接收一个返回promise组件的函数：<code>const List=()=&gt;import(&#39;@/components/list.vue&#39;)</code>或<code>const UserDetails = () =&gt; import(/* webpackChunkName: &quot;group-user&quot; */ &#39;./UserDetails.vue&#39;)</code></li><li>vue异步组件技术：<code>component: resolve =&gt; require([&#39;@/components/list&#39;], resolve)</code></li><li>webpack的<code>require.ensure()</code>，旧版本中使用。</li></ol><h2 id="vuex" tabindex="-1">Vuex <a class="header-anchor" href="#vuex" aria-label="Permalink to &quot;Vuex&quot;">​</a></h2><h3 id="vuex的原理" tabindex="-1">vuex的原理 <a class="header-anchor" href="#vuex的原理" aria-label="Permalink to &quot;vuex的原理&quot;">​</a></h3><p>专为vue开发的全局状态管理机制，可以方便实现组件之间的数据共享；单一数据源，核心就是store（仓库），易于开发和维护；数据是响应式的。</p><ul><li>state：单一状态树，每个应用仅包含一个store实例，一般不可以直接修改里面的数据。</li><li>mutations：用来定义修改store中数据的同步方法，第一个参数是state</li><li>action：类似mutation，可以包含异步操作，它的参数是一个与store具有相同方法和属性的context对象。通过commit提交一个mutation，可以通过dispath调用其它action，可以通过context.state、context.getters获取实例数据。</li><li>getters：类似组件中的计算属性，用来对一些数据进行过滤。也有缓存性。</li><li>modules：在项目比较复杂时，可以进行模块划分，每个模板拥有自己的state、mutation、action、getters，方便维护</li></ul><h3 id="action与mutation的区别" tabindex="-1">action与mutation的区别 <a class="header-anchor" href="#action与mutation的区别" aria-label="Permalink to &quot;action与mutation的区别&quot;">​</a></h3><p>mutation：必为同步函数，专注于修改state中的数据，通过commit来提交要操作的内容，它接受state为第一个参数</p><p>action：类似mutation，可包含异步操作，它提交的是mutation，不能直接操作state，它接受一个与store实例具有相同方法和属性的context对象，可以通过commit提交一个mutation，可以通过dispath调用其它action，可以通过context.state、context.getters获取实例数据。</p><h3 id="vuex与localstorage的区别" tabindex="-1">vuex与localStorage的区别 <a class="header-anchor" href="#vuex与localstorage的区别" aria-label="Permalink to &quot;vuex与localStorage的区别&quot;">​</a></h3><p>vuex：存储在内存中，用于全局共享状态数据、跨组件传值，响应式，页面刷新时数据会丢失</p><p>localStorage：存储在浏览器本地，字符串形式永久存储，一般是跨页面传递数据，数据不能响应式，页面刷新数据不丢失</p><h3 id="vuex的严格模式" tabindex="-1">vuex的严格模式 <a class="header-anchor" href="#vuex的严格模式" aria-label="Permalink to &quot;vuex的严格模式&quot;">​</a></h3><p>在严格模式下，只能由mutation函数改变state中数据，否则将报错，来保证所有的状态变更都能被调试工具跟踪到。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> store </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">new</span><span style="color:#BABED8;"> Vuex</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">Store</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#F07178;">strict</span><span style="color:#89DDFF;">:</span><span style="color:#FF9CAC;">true</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#BABED8;">)</span></span></code></pre></div><h2 id="pinia" tabindex="-1">Pinia <a class="header-anchor" href="#pinia" aria-label="Permalink to &quot;Pinia&quot;">​</a></h2>`,64),l=[r];function n(p,i,c,u,h,d){return a(),o("div",null,l)}const y=e(t,[["render",n]]);export{F as __pageData,y as default};
