[TOC]



### 防抖函数

```js
function debounce(func,duration=500){
  let timerId;
  return function (...args){  // 通过 args 提取要传递的参数
    if(timerId){
      clearTimeout(timerId);
      timerId=null;
    }
    settimeOut(()=>{
      func.apply(this,args); // 保证 this 的指向，同时给要执行的函数传参
    },duration)
  }
}
```



### 节流函数

### 

```js
// 节流函数：时间戳版
function throttle(fn, delay) {
  let preTime = Date.now();

  return function (...args) {
    const nowTime = Date.now();

    if (nowTime - preTime >= delay) {
      preTime = Date.now();
      return fn.apply(this, args);
    }
  };
}

// 定时器版
function throttle(fn, wait) {
  let timeout = null;

  return function (...args) {
    if (!timeout) {
      timeout = setTimeout(() => {
        fn.apply(this, args);
        timeout = null;
      }, wait);
    }
  };
}
```





### instanceof 的实现

```js
function myInstanceof(left,right){
  // 获取对象的原型
  let proto=Object.getPrototypeOf(left)
  // 获取构造函数的 prototype 对象
  let prototype=right.prototype;
  // 判断构造函数的 prototype 对象是否在对象的原型链上
  while(true){
    if(!proto) return false;
    if(proto===prototype) return true;
    // 如果没有找到，就继续从其原型上找，Object.getPrototypeOf方法用来获取指定对象的原型
    proto=Object.getPrototypeOf(proto);
  }
}
```



### new 操作符

```js
//Fun为构造函数, args表示传参
function myNew(Fun, ...args) {
    // 1.在内存中创建一个新对象
    let obj = {};
    
    // 2.把新对象的原型指针指向构造函数的原型属性
    obj.__proto__ = Fun.prototype;
    
    // 3.改变this指向，并且执行构造函数内部的代码（传参）
    let res = Fun.apply(obj, args);
    
    // 4.判断函数执行结果的类型
    if (res instanceof Object) {
        return res;
    } else {
        return obj;
    }
}

function One(name, age) {
    this.name = name;
    this.age = age;
}
let a = new One();
console.log(a);


let obj = myNew(One, "XiaoMing", "18");
console.log("newObj:", obj);
```



### ajax、promise、async/await

```js
const ajax = (method, url, data, success, fail) => {
  	//1、创建一个XMLHttpRequest对象的实例
    var request = new XMLHttpRequest()
    
    //2、创建HTTP请求，可以使用XMLHttpRequest的open方法
    request.open(method, url);
  
  	//3、设置响应HTTP请求状态变化事件的回调函数
    request.onreadystatechange = function(){
        //判断XMLHttpRequest对象的readyState属性值是否为4表示异步调用完成
      	if(request.readyState !== 4) return;
        //4、设置获取服务器返回数据的语句
        if(xhr.status==200){
           //得到返回结果，对返回结果做一些操作
            success (request)
        } else {
            fail(request)
        }
    }
  
  	//设置请求失败时的监听函数
  	xhr.onerror=function(){
      console.log(this.statusText)
    }
  
  	// 设置请求头
  	xhr.responseType='json'
  	xhr.setRequestHeader("Accept","application/json")
  
  	//发送HTTP请求
    request.send();
}
```



### Promise 封装 ajax

```js
function getJson(url) {
  return new Promise((resolve, reject) => {
    // 创建XMLHttpRequest对象
    let xhr = new XMLHttpRequest();
    // 设置请求方式和请求地址
    xhr.open("GET", url, true);
    // 设置状态监听函数
    xhr.onreadystatechange = () => {
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
          resolve(xhr.responseText);
        } else {
          reject(new Error(xhr.statusText));
        }
      }
    };
    // 设置错误监听函数
    xhr.onerror = () => {
      reject(new Error(xhr.statusText));
    };
    // 设置请求头
    xhr.responseType = "json";
    xhr.setRequestHeader("Accept", "application/json");
    // 发送请求
    xhr.send();
  });
}
```



### Vue2 对数组方法的重写

```
```

